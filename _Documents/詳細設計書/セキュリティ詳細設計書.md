# 詳細設計書 - セキュリティ詳細設計書

## 1. セキュリティ概要

### 1.1 セキュリティ方針
| 項目 | 内容 |
|------|------|
| セキュリティフレームワーク | OWASP Top 10準拠 |
| 認証方式 | JWT + OAuth 2.0 |
| 暗号化標準 | AES-256, TLS 1.3 |
| アクセス制御 | RBAC (Role-Based Access Control) |
| 監査要件 | 全操作ログ取得・3年保存 |
| コンプライアンス | 個人情報保護法・GDPR準拠 |

### 1.2 セキュリティ層構成
```
┌─ アプリケーション層 ─┐
│ - 入力値検証        │
│ - 認証・認可        │
│ - セッション管理    │
│ - CSRF対策         │
└─────────────────────┘
┌─ ネットワーク層 ─┐
│ - WAF            │
│ - DDoS対策       │
│ - レート制限     │
│ - IP制限         │
└─────────────────────┘
┌─ インフラ層 ─┐
│ - VPC分離     │
│ - FW設定     │
│ - 侵入検知   │
│ - 暗号化     │
└─────────────────┘
```

## 2. 認証・認可設計

### 2.1 JWT認証実装
```typescript
interface JWTPayload {
  userId: string
  companyId: string
  roles: string[]
  permissions: string[]
  iat: number
  exp: number
  iss: string
  aud: string
}

class AuthService {
  private readonly jwtSecret: string
  private readonly jwtExpiry: string = '8h'
  private readonly refreshExpiry: string = '30d'
  
  // JWT生成
  async generateToken(user: User): Promise<AuthTokens> {
    const payload: JWTPayload = {
      userId: user.id,
      companyId: user.companyId,
      roles: user.roles.map(role => role.name),
      permissions: await this.getUserPermissions(user),
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + (8 * 60 * 60), // 8時間
      iss: 'engineer-skillsheet-system',
      aud: 'engineer-skillsheet-client'
    }
    
    const accessToken = jwt.sign(payload, this.jwtSecret, {
      algorithm: 'HS256'
    })
    
    const refreshToken = await this.generateRefreshToken(user.id)
    
    return { accessToken, refreshToken }
  }
  
  // トークン検証
  async verifyToken(token: string): Promise<JWTPayload> {
    try {
      const decoded = jwt.verify(token, this.jwtSecret) as JWTPayload
      
      // ブラックリストチェック
      if (await this.isTokenBlacklisted(token)) {
        throw new AuthError('Token has been revoked')
      }
      
      // ユーザー有効性チェック
      const user = await userRepository.findById(decoded.userId)
      if (!user || !user.isActive) {
        throw new AuthError('User is not active')
      }
      
      return decoded
    } catch (error) {
      throw new AuthError('Invalid token')
    }
  }
  
  // リフレッシュトークン生成
  private async generateRefreshToken(userId: string): Promise<string> {
    const refreshToken = crypto.randomBytes(64).toString('hex')
    const expiry = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30日
    
    await refreshTokenRepository.create({
      token: refreshToken,
      userId,
      expiresAt: expiry
    })
    
    return refreshToken
  }
}
```

### 2.2 権限ベースアクセス制御（RBAC）
```typescript
interface Permission {
  id: string
  name: string
  resource: string
  action: string
  description: string
}

interface Role {
  id: string
  name: string
  displayName: string
  permissions: Permission[]
  isSystem: boolean
}

class AuthorizationService {
  // 権限チェック
  async checkPermission(
    userId: string, 
    resource: string, 
    action: string
  ): Promise<boolean> {
    const userPermissions = await this.getUserPermissions(userId)
    
    return userPermissions.some(permission => 
      permission.resource === resource && 
      permission.action === action
    )
  }
  
  // リソースレベル権限チェック
  async checkResourceAccess(
    userId: string, 
    resourceType: string, 
    resourceId: string
  ): Promise<boolean> {
    const user = await userRepository.findById(userId)
    
    // テナント分離チェック
    if (resourceType === 'engineer' || resourceType === 'project') {
      const resource = await this.getResource(resourceType, resourceId)
      return resource.companyId === user.companyId
    }
    
    return false
  }
  
  // 管理者権限チェック
  async isAdmin(userId: string): Promise<boolean> {
    const userRoles = await this.getUserRoles(userId)
    return userRoles.some(role => role.name === 'admin')
  }
}

// 権限チェックミドルウェア
export const requirePermission = (resource: string, action: string) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const hasPermission = await authorizationService.checkPermission(
        req.user.id, 
        resource, 
        action
      )
      
      if (!hasPermission) {
        return res.status(403).json({ 
          error: 'Insufficient permissions',
          required: { resource, action }
        })
      }
      
      next()
    } catch (error) {
      res.status(500).json({ error: 'Authorization check failed' })
    }
  }
}

// 使用例
router.get('/engineers', 
  authenticateToken,
  requirePermission('engineer', 'read'),
  getEngineers
)

router.post('/engineers', 
  authenticateToken,
  requirePermission('engineer', 'create'),
  createEngineer
)
```

### 2.3 多要素認証（MFA）
```typescript
interface MFAService {
  // TOTP設定
  async setupTOTP(userId: string): Promise<MFASetupResult> {
    const secret = speakeasy.generateSecret({
      name: `Engineer Skillsheet (${user.email})`,
      issuer: 'Engineer Skillsheet System'
    })
    
    // 秘密鍵を暗号化して保存
    await mfaRepository.create({
      userId,
      secretKey: encrypt(secret.base32),
      isEnabled: false,
      type: 'totp'
    })
    
    return {
      secret: secret.base32,
      qrCode: secret.otpauth_url,
      backupCodes: await this.generateBackupCodes(userId)
    }
  }
  
  // TOTP検証
  async verifyTOTP(userId: string, token: string): Promise<boolean> {
    const mfaConfig = await mfaRepository.findByUserId(userId)
    if (!mfaConfig || !mfaConfig.isEnabled) {
      return false
    }
    
    const secretKey = decrypt(mfaConfig.secretKey)
    
    return speakeasy.totp.verify({
      secret: secretKey,
      encoding: 'base32',
      token,
      window: 2 // 許容時間差
    })
  }
  
  // バックアップコード生成
  private async generateBackupCodes(userId: string): Promise<string[]> {
    const codes = Array.from({ length: 10 }, () => 
      crypto.randomBytes(4).toString('hex').toUpperCase()
    )
    
    const hashedCodes = codes.map(code => bcrypt.hashSync(code, 10))
    
    await backupCodeRepository.create({
      userId,
      codes: hashedCodes
    })
    
    return codes
  }
}
```

## 3. データ保護・暗号化

### 3.1 保存時暗号化
```typescript
class EncryptionService {
  private readonly algorithm = 'aes-256-gcm'
  private readonly keyDerivation = 'pbkdf2'
  
  // データ暗号化
  async encrypt(plaintext: string, context?: string): Promise<EncryptedData> {
    const key = await this.deriveKey(context)
    const iv = crypto.randomBytes(16)
    const cipher = crypto.createCipher(this.algorithm, key)
    
    cipher.setAAD(Buffer.from(context || ''))
    
    let encrypted = cipher.update(plaintext, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    const authTag = cipher.getAuthTag()
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      algorithm: this.algorithm
    }
  }
  
  // データ復号化
  async decrypt(encryptedData: EncryptedData, context?: string): Promise<string> {
    const key = await this.deriveKey(context)
    const decipher = crypto.createDecipher(
      encryptedData.algorithm, 
      key
    )
    
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'))
    decipher.setAAD(Buffer.from(context || ''))
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
  
  // キー導出
  private async deriveKey(context?: string): Promise<Buffer> {
    const masterKey = process.env.ENCRYPTION_MASTER_KEY
    const salt = crypto.scryptSync(context || 'default', 'salt', 32)
    
    return crypto.pbkdf2Sync(masterKey, salt, 100000, 32, 'sha512')
  }
}

// 機密データ暗号化モデル
class EncryptedField {
  constructor(
    private encryptionService: EncryptionService,
    private context: string
  ) {}
  
  // Sequelize getter/setter
  get(value: string): string {
    if (!value) return value
    const encryptedData = JSON.parse(value)
    return this.encryptionService.decrypt(encryptedData, this.context)
  }
  
  set(value: string): void {
    if (!value) return value
    const encryptedData = this.encryptionService.encrypt(value, this.context)
    return JSON.stringify(encryptedData)
  }
}

// 使用例
const UserModel = sequelize.define('User', {
  email: DataTypes.STRING,
  personalEmail: {
    type: DataTypes.TEXT,
    get() {
      return new EncryptedField(encryptionService, 'personal_email')
        .get(this.getDataValue('personalEmail'))
    },
    set(value: string) {
      this.setDataValue('personalEmail', 
        new EncryptedField(encryptionService, 'personal_email').set(value)
      )
    }
  }
})
```

### 3.2 転送時暗号化
```typescript
// HTTPS設定
const httpsOptions = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem'),
  ca: fs.readFileSync('ca-certificate.pem'),
  
  // TLS 1.3最小バージョン
  secureProtocol: 'TLSv1_3_method',
  
  // 暗号スイート制限
  ciphers: [
    'ECDHE-RSA-AES128-GCM-SHA256',
    'ECDHE-RSA-AES256-GCM-SHA384',
    'ECDHE-RSA-AES128-SHA256',
    'ECDHE-RSA-AES256-SHA384'
  ].join(':'),
  
  // Perfect Forward Secrecy
  honorCipherOrder: true
}

const server = https.createServer(httpsOptions, app)

// セキュリティヘッダー設定
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"]
    }
  },
  crossOriginEmbedderPolicy: { policy: "require-corp" },
  crossOriginOpenerPolicy: { policy: "same-origin" },
  crossOriginResourcePolicy: { policy: "same-origin" },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}))
```

## 4. 入力値検証・サニタイゼーション

### 4.1 入力値検証
```typescript
// XSS対策
import DOMPurify from 'dompurify'
import { JSDOM } from 'jsdom'

class InputSanitizer {
  private window = new JSDOM('').window
  private DOMPurify = DOMPurify(this.window)
  
  // HTML文字列サニタイゼーション
  sanitizeHTML(input: string): string {
    return this.DOMPurify.sanitize(input, {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
      ALLOWED_ATTR: []
    })
  }
  
  // SQLインジェクション対策（追加チェック）
  validateSQL(input: string): boolean {
    const sqlPatterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/i,
      /(--|\/\*|\*\/|;)/,
      /(\b(OR|AND)\b.*=.*)/i
    ]
    
    return !sqlPatterns.some(pattern => pattern.test(input))
  }
  
  // ファイル名サニタイゼーション
  sanitizeFileName(fileName: string): string {
    return fileName
      .replace(/[^a-zA-Z0-9._-]/g, '_')
      .replace(/_{2,}/g, '_')
      .substring(0, 255)
  }
}

// バリデーションミドルウェア
export const sanitizeInput = (req: Request, res: Response, next: NextFunction) => {
  const sanitizer = new InputSanitizer()
  
  // リクエストボディサニタイゼーション
  if (req.body && typeof req.body === 'object') {
    req.body = sanitizeObject(req.body, sanitizer)
  }
  
  // クエリパラメータサニタイゼーション
  if (req.query && typeof req.query === 'object') {
    req.query = sanitizeObject(req.query, sanitizer)
  }
  
  next()
}

function sanitizeObject(obj: any, sanitizer: InputSanitizer): any {
  const sanitized: any = {}
  
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'string') {
      sanitized[key] = sanitizer.sanitizeHTML(value)
    } else if (typeof value === 'object' && value !== null) {
      sanitized[key] = sanitizeObject(value, sanitizer)
    } else {
      sanitized[key] = value
    }
  }
  
  return sanitized
}
```

### 4.2 CSRF対策
```typescript
import csrf from 'csurf'

// CSRF トークン設定
const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
})

app.use(csrfProtection)

// CSRFトークン提供エンドポイント
app.get('/api/csrf-token', (req: Request, res: Response) => {
  res.json({ csrfToken: req.csrfToken() })
})

// フロントエンド側実装
class CSRFProtection {
  private csrfToken: string | null = null
  
  async getCsrfToken(): Promise<string> {
    if (!this.csrfToken) {
      const response = await fetch('/api/csrf-token')
      const data = await response.json()
      this.csrfToken = data.csrfToken
    }
    return this.csrfToken
  }
  
  async makeSecureRequest(url: string, options: RequestInit = {}): Promise<Response> {
    const csrfToken = await this.getCsrfToken()
    
    return fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'X-CSRF-Token': csrfToken
      }
    })
  }
}
```

## 5. セッション管理

### 5.1 セキュアセッション
```typescript
interface SessionConfig {
  secret: string
  resave: boolean
  saveUninitialized: boolean
  cookie: {
    secure: boolean
    httpOnly: boolean
    maxAge: number
    sameSite: 'strict' | 'lax' | 'none'
  }
  store: RedisStore
  name: string
}

const sessionConfig: SessionConfig = {
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 30 * 60 * 1000, // 30分
    sameSite: 'strict'
  },
  store: new RedisStore({
    client: redisClient,
    prefix: 'sess:',
    ttl: 1800 // 30分
  }),
  name: 'sessionId'
}

app.use(session(sessionConfig))

// セッションハイジャック対策
class SessionSecurity {
  // セッション再生成
  async regenerateSession(req: Request): Promise<void> {
    return new Promise((resolve, reject) => {
      req.session.regenerate((err) => {
        if (err) reject(err)
        else resolve()
      })
    })
  }
  
  // セッション固定攻撃対策
  async rotateSessionOnLogin(req: Request, user: User): Promise<void> {
    const oldSessionId = req.sessionID
    
    // 新しいセッション生成
    await this.regenerateSession(req)
    
    // ユーザー情報設定
    req.session.userId = user.id
    req.session.loginTime = new Date()
    req.session.ipAddress = req.ip
    req.session.userAgent = req.get('User-Agent')
    
    // 古いセッション削除
    await sessionStore.destroy(oldSessionId)
  }
  
  // 同時ログイン制限
  async enforceSessionLimit(userId: string, maxSessions: number = 3): Promise<void> {
    const userSessions = await this.getUserSessions(userId)
    
    if (userSessions.length >= maxSessions) {
      // 古いセッションを削除
      const sessionsToRemove = userSessions
        .sort((a, b) => a.lastAccess - b.lastAccess)
        .slice(0, userSessions.length - maxSessions + 1)
      
      for (const session of sessionsToRemove) {
        await sessionStore.destroy(session.id)
      }
    }
  }
}
```

## 6. 監査ログ・セキュリティモニタリング

### 6.1 監査ログ設計
```typescript
interface AuditLogEntry {
  id: string
  timestamp: Date
  userId?: string
  companyId?: string
  action: string
  resource: string
  resourceId?: string
  ipAddress: string
  userAgent: string
  outcome: 'success' | 'failure'
  details?: Record<string, any>
  riskLevel: 'low' | 'medium' | 'high' | 'critical'
}

class AuditLogger {
  // 監査ログ記録
  async log(entry: Omit<AuditLogEntry, 'id' | 'timestamp'>): Promise<void> {
    const auditEntry: AuditLogEntry = {
      id: uuidv4(),
      timestamp: new Date(),
      ...entry
    }
    
    // データベース保存
    await auditLogRepository.create(auditEntry)
    
    // 高リスクアクションの場合は即座通知
    if (entry.riskLevel === 'critical' || entry.riskLevel === 'high') {
      await this.sendSecurityAlert(auditEntry)
    }
  }
  
  // セキュリティアラート送信
  private async sendSecurityAlert(entry: AuditLogEntry): Promise<void> {
    await notificationService.send({
      type: 'security-alert',
      recipients: ['security@company.com'],
      subject: `Security Alert: ${entry.action}`,
      data: entry
    })
  }
}

// 監査ログミドルウェア
export const auditLog = (action: string, resource: string) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now()
    
    // レスポンス完了時にログ記録
    res.on('finish', async () => {
      const duration = Date.now() - startTime
      const outcome = res.statusCode < 400 ? 'success' : 'failure'
      
      await auditLogger.log({
        userId: req.user?.id,
        companyId: req.user?.companyId,
        action,
        resource,
        resourceId: req.params.id,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent') || '',
        outcome,
        details: {
          method: req.method,
          url: req.originalUrl,
          statusCode: res.statusCode,
          duration
        },
        riskLevel: this.calculateRiskLevel(action, outcome, req)
      })
    })
    
    next()
  }
  
  private calculateRiskLevel(
    action: string, 
    outcome: string, 
    req: Request
  ): AuditLogEntry['riskLevel'] {
    // 高リスクアクション
    const highRiskActions = ['delete', 'admin_action', 'export_data']
    if (highRiskActions.includes(action)) return 'high'
    
    // 失敗したログインは中リスク
    if (action === 'login' && outcome === 'failure') return 'medium'
    
    return 'low'
  }
}

// 使用例
router.post('/login', 
  auditLog('login', 'auth'),
  loginHandler
)

router.delete('/engineers/:id', 
  authenticateToken,
  auditLog('delete', 'engineer'),
  deleteEngineer
)
```

### 6.2 セキュリティモニタリング
```typescript
class SecurityMonitor {
  // 異常ログイン検知
  async detectAnomalousLogin(userId: string, loginAttempt: LoginAttempt): Promise<boolean> {
    const recentLogins = await this.getRecentLogins(userId, 24) // 24時間以内
    
    // 地理的異常検知
    if (await this.isGeographicallyAnomalous(loginAttempt, recentLogins)) {
      await this.alertSuspiciousActivity(userId, 'geographical_anomaly', loginAttempt)
      return true
    }
    
    // デバイス異常検知
    if (await this.isDeviceAnomalous(loginAttempt, recentLogins)) {
      await this.alertSuspiciousActivity(userId, 'device_anomaly', loginAttempt)
      return true
    }
    
    // 時間帯異常検知
    if (await this.isTimeAnomalous(loginAttempt, recentLogins)) {
      await this.alertSuspiciousActivity(userId, 'time_anomaly', loginAttempt)
      return true
    }
    
    return false
  }
  
  // ブルートフォース攻撃検知
  async detectBruteForce(ipAddress: string): Promise<boolean> {
    const window = 15 * 60 * 1000 // 15分
    const threshold = 10 // 閾値
    
    const failedAttempts = await loginAttemptRepository.countFailedAttempts({
      ipAddress,
      timeWindow: window
    })
    
    if (failedAttempts >= threshold) {
      await this.blockIP(ipAddress, '1h')
      await this.alertBruteForceAttempt(ipAddress, failedAttempts)
      return true
    }
    
    return false
  }
  
  // DDoS攻撃検知
  async detectDDoS(): Promise<boolean> {
    const metrics = await this.getRealtimeMetrics()
    
    if (metrics.requestsPerSecond > 1000 && 
        metrics.errorRate > 0.5 &&
        metrics.uniqueIPs < metrics.requestsPerSecond * 0.1) {
      
      await this.activateDDoSProtection()
      await this.alertDDoSAttack(metrics)
      return true
    }
    
    return false
  }
}

// リアルタイムセキュリティモニタリング
setInterval(async () => {
  const monitor = new SecurityMonitor()
  
  // DDoS攻撃チェック
  await monitor.detectDDoS()
  
  // 異常なAPIアクセスパターンチェック
  await monitor.detectAnomalousAPIUsage()
  
  // システムリソース監視
  await monitor.monitorSystemResources()
  
}, 60000) // 1分間隔
```

## 7. インシデント対応

### 7.1 セキュリティインシデント管理
```typescript
interface SecurityIncident {
  id: string
  type: 'data_breach' | 'unauthorized_access' | 'malware' | 'ddos' | 'other'
  severity: 'low' | 'medium' | 'high' | 'critical'
  status: 'detected' | 'investigating' | 'contained' | 'resolved'
  detectedAt: Date
  description: string
  affectedUsers?: string[]
  affectedSystems?: string[]
  responseActions: string[]
  assignedTo?: string
  resolvedAt?: Date
}

class IncidentResponse {
  // インシデント作成
  async createIncident(incident: Omit<SecurityIncident, 'id' | 'detectedAt' | 'status'>): Promise<SecurityIncident> {
    const newIncident: SecurityIncident = {
      id: uuidv4(),
      detectedAt: new Date(),
      status: 'detected',
      responseActions: [],
      ...incident
    }
    
    await incidentRepository.create(newIncident)
    
    // 緊急度に応じた通知
    await this.notifyIncident(newIncident)
    
    // 自動対応アクション実行
    await this.executeAutoResponse(newIncident)
    
    return newIncident
  }
  
  // 自動対応アクション
  private async executeAutoResponse(incident: SecurityIncident): Promise<void> {
    switch (incident.type) {
      case 'unauthorized_access':
        await this.handleUnauthorizedAccess(incident)
        break
      case 'data_breach':
        await this.handleDataBreach(incident)
        break
      case 'ddos':
        await this.handleDDoSAttack(incident)