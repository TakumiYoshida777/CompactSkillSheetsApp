# 詳細設計書 - バッチ処理設計書

## 1. バッチ処理概要

### 1.1 設計方針
| 項目 | 内容 |
|------|------|
| 実行基盤 | Node.js + TypeScript |
| スケジューラー | Cron + node-cron |
| ジョブキュー | Bull Queue (Redis) |
| ログ管理 | Winston + ログローテーション |
| エラーハンドリング | リトライ機能付き |
| 監視 | Prometheus メトリクス |

### 1.2 バッチ分類
```
バッチ処理
├── 日次処理
│   ├── データ集計・レポート生成
│   ├── バックアップ処理
│   └── アカウント状態チェック
├── 週次処理
│   ├── システムメンテナンス
│   └── パフォーマンス分析
├── 月次処理
│   ├── 請求書生成
│   └── 利用統計レポート
└── リアルタイム処理
    ├── 定期アプローチ送信
    ├── 通知配信
    └── ステータス自動更新
```

## 2. 日次バッチ処理

### 2.1 待機ステータス自動更新バッチ
```
バッチID: DAILY_001
実行時間: 毎日 02:00
概要: プロジェクト終了予定日に基づく待機ステータス自動更新
```

#### 処理フロー
```typescript
interface EngineerStatusUpdateJob {
  name: 'engineer-status-update'
  schedule: '0 2 * * *' // 毎日 02:00
}

async function updateEngineerStatus() {
  try {
    // 1. 対象エンジニア抽出
    const targetEngineers = await getEngineersForStatusUpdate()
    
    // 2. ステータス更新処理
    for (const engineer of targetEngineers) {
      await updateEngineerStatusByProject(engineer)
    }
    
    // 3. 処理結果ログ出力
    logger.info('Engineer status update completed', {
      processedCount: targetEngineers.length,
      timestamp: new Date()
    })
    
  } catch (error) {
    logger.error('Engineer status update failed', { error })
    throw error
  }
}

// 対象エンジニア抽出ロジック
async function getEngineersForStatusUpdate(): Promise<Engineer[]> {
  const today = new Date()
  const threeMonthsLater = new Date(today.getTime() + 90 * 24 * 60 * 60 * 1000)
  
  return await engineerRepository.findEngineersWithProjectEndingSoon({
    currentStatus: 'working',
    projectEndDateBefore: threeMonthsLater
  })
}

// ステータス更新ロジック
async function updateEngineerStatusByProject(engineer: Engineer): Promise<void> {
  const currentProject = await projectRepository.getCurrentProject(engineer.id)
  
  if (!currentProject) {
    // 現在のプロジェクトがない場合は待機中に更新
    await engineerRepository.updateStatus(engineer.id, 'waiting')
    return
  }
  
  const today = new Date()
  const plannedEndDate = new Date(currentProject.plannedEndDate)
  const daysDifference = Math.ceil((plannedEndDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24))
  
  if (daysDifference <= 0) {
    // プロジェクト終了済み → 待機中
    await engineerRepository.updateStatus(engineer.id, 'waiting')
  } else if (daysDifference <= 90) {
    // 3ヶ月以内に終了予定 → 待機予定
    await engineerRepository.updateStatus(engineer.id, 'waiting_soon')
  }
  // それ以外は稼働中のまま
}
```

### 2.2 日次データ集計バッチ
```
バッチID: DAILY_002
実行時間: 毎日 03:00
概要: 利用状況データの集計とレポート生成
```

#### 処理内容
```typescript
interface DailyAggregationJob {
  name: 'daily-data-aggregation'
  schedule: '0 3 * * *'
}

async function runDailyAggregation() {
  const yesterday = new Date()
  yesterday.setDate(yesterday.getDate() - 1)
  
  try {
    // 1. 企業別利用状況集計
    await aggregateCompanyUsage(yesterday)
    
    // 2. システム全体統計集計
    await aggregateSystemStats(yesterday)
    
    // 3. エンジニア活動統計
    await aggregateEngineerActivity(yesterday)
    
    // 4. アプローチ効果測定
    await aggregateApproachMetrics(yesterday)
    
    logger.info('Daily aggregation completed', { date: yesterday })
    
  } catch (error) {
    logger.error('Daily aggregation failed', { error, date: yesterday })
    throw error
  }
}

// 企業別利用状況集計
async function aggregateCompanyUsage(date: Date): Promise<void> {
  const companies = await companyRepository.findActiveCompanies()
  
  for (const company of companies) {
    const usageData = {
      companyId: company.id,
      date,
      activeUsers: await getUserActivityCount(company.id, date),
      totalEngineers: await getEngineerCount(company.id),
      activeEngineers: await getActiveEngineerCount(company.id, date),
      approachCount: await getApproachCount(company.id, date),
      emailSentCount: await getEmailSentCount(company.id, date),
      loginCount: await getLoginCount(company.id, date),
      storageUsageMb: await getStorageUsage(company.id),
      apiCallCount: await getApiCallCount(company.id, date),
      featureUsage: await getFeatureUsage(company.id, date)
    }
    
    await usageLogRepository.create(usageData)
  }
}

// システム全体統計集計
async function aggregateSystemStats(date: Date): Promise<void> {
  const stats = {
    date,
    totalUsers: await userRepository.count(),
    activeUsers: await userRepository.countActiveUsers(date),
    totalEngineers: await engineerRepository.count(),
    totalCompanies: await companyRepository.count(),
    totalApproaches: await approachRepository.countByDate(date),
    systemUptime: await getSystemUptime(),
    responseTimeAvg: await getAverageResponseTime(date),
    errorRate: await getErrorRate(date)
  }
  
  await systemStatsRepository.create(stats)
}
```

### 2.3 定期バックアップバッチ
```
バッチID: DAILY_003
実行時間: 毎日 01:00
概要: データベースとファイルの自動バックアップ
```

#### 処理内容
```typescript
interface BackupJob {
  name: 'daily-backup'
  schedule: '0 1 * * *'
}

async function runDailyBackup() {
  const backupDate = new Date().toISOString().split('T')[0]
  
  try {
    // 1. データベースバックアップ
    await createDatabaseBackup(backupDate)
    
    // 2. ファイルストレージバックアップ
    await createFileStorageBackup(backupDate)
    
    // 3. 古いバックアップファイル削除
    await cleanupOldBackups()
    
    // 4. バックアップ整合性チェック
    await verifyBackupIntegrity(backupDate)
    
    logger.info('Daily backup completed', { date: backupDate })
    
  } catch (error) {
    logger.error('Daily backup failed', { error, date: backupDate })
    throw error
  }
}

// データベースバックアップ
async function createDatabaseBackup(date: string): Promise<void> {
  const backupFileName = `database_backup_${date}.sql`
  const backupPath = `/backups/daily/${backupFileName}`
  
  // pg_dumpを使用したPostgreSQLバックアップ
  const command = `pg_dump ${process.env.DATABASE_URL} > ${backupPath}`
  
  await executeCommand(command)
  
  // S3への転送
  await uploadToS3(backupPath, `backups/daily/${backupFileName}`)
  
  // 暗号化して遠隔地保存
  await encryptAndTransfer(backupPath, 'remote-backup-site')
}

// ファイルストレージバックアップ
async function createFileStorageBackup(date: string): Promise<void> {
  const files = await fileRepository.findAll()
  
  for (const file of files) {
    await copyFileToBackupLocation(file, date)
  }
}

// 古いバックアップ削除（30日保持）
async function cleanupOldBackups(): Promise<void> {
  const thirtyDaysAgo = new Date()
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
  
  await deleteBackupsOlderThan(thirtyDaysAgo)
}
```

## 3. 週次バッチ処理

### 3.1 システムメンテナンスバッチ
```
バッチID: WEEKLY_001
実行時間: 毎週日曜日 04:00
概要: システムの定期メンテナンス処理
```

#### 処理内容
```typescript
interface WeeklyMaintenanceJob {
  name: 'weekly-maintenance'
  schedule: '0 4 * * 0' // 毎週日曜日 04:00
}

async function runWeeklyMaintenance() {
  try {
    // 1. データベース最適化
    await optimizeDatabase()
    
    // 2. ログファイルローテーション
    await rotateLogFiles()
    
    // 3. キャッシュクリア
    await clearExpiredCache()
    
    // 4. 一時ファイル削除
    await cleanupTempFiles()
    
    // 5. システムヘルスチェック
    await performHealthCheck()
    
    logger.info('Weekly maintenance completed')
    
  } catch (error) {
    logger.error('Weekly maintenance failed', { error })
    throw error
  }
}

// データベース最適化
async function optimizeDatabase(): Promise<void> {
  // インデックス再構築
  await executeSQL('REINDEX DATABASE engineer_skillsheet')
  
  // 統計情報更新
  await executeSQL('ANALYZE')
  
  // 不要データ削除
  await cleanupOldLogs()
  await cleanupExpiredSessions()
}

// ログファイルローテーション
async function rotateLogFiles(): Promise<void> {
  const logDir = '/var/log/app'
  const archiveDir = '/var/log/app/archive'
  
  // 1週間以上前のログをアーカイブ
  await archiveOldLogs(logDir, archiveDir, 7)
  
  // 3ヶ月以上前のアーカイブログを削除
  await deleteOldArchives(archiveDir, 90)
}
```

### 3.2 パフォーマンス分析バッチ
```
バッチID: WEEKLY_002
実行時間: 毎週月曜日 05:00
概要: 週次パフォーマンス分析とレポート生成
```

#### 処理内容
```typescript
interface PerformanceAnalysisJob {
  name: 'weekly-performance-analysis'
  schedule: '0 5 * * 1' // 毎週月曜日 05:00
}

async function runPerformanceAnalysis() {
  const lastWeek = getLastWeekDateRange()
  
  try {
    // 1. レスポンスタイム分析
    const responseTimeMetrics = await analyzeResponseTimes(lastWeek)
    
    // 2. エラー率分析
    const errorMetrics = await analyzeErrorRates(lastWeek)
    
    // 3. データベースパフォーマンス分析
    const dbMetrics = await analyzeDatabasePerformance(lastWeek)
    
    // 4. API使用状況分析
    const apiMetrics = await analyzeApiUsage(lastWeek)
    
    // 5. レポート生成
    await generatePerformanceReport({
      responseTimeMetrics,
      errorMetrics,
      dbMetrics,
      apiMetrics,
      period: lastWeek
    })
    
    logger.info('Performance analysis completed', { period: lastWeek })
    
  } catch (error) {
    logger.error('Performance analysis failed', { error })
    throw error
  }
}
```

## 4. 月次バッチ処理

### 4.1 請求書生成バッチ
```
バッチID: MONTHLY_001
実行時間: 毎月1日 06:00
概要: 前月分の請求書自動生成
```

#### 処理内容
```typescript
interface InvoiceGenerationJob {
  name: 'monthly-invoice-generation'
  schedule: '0 6 1 * *' // 毎月1日 06:00
}

async function generateMonthlyInvoices() {
  const lastMonth = getLastMonthDateRange()
  
  try {
    // 1. 請求対象契約取得
    const activeContracts = await contractRepository.findActiveContracts()
    
    // 2. 各契約の請求書生成
    for (const contract of activeContracts) {
      await generateInvoiceForContract(contract, lastMonth)
    }
    
    // 3. 請求書メール送信
    await sendInvoiceEmails(lastMonth)
    
    logger.info('Monthly invoice generation completed', { 
      period: lastMonth,
      contractCount: activeContracts.length 
    })
    
  } catch (error) {
    logger.error('Monthly invoice generation failed', { error })
    throw error
  }
}

// 契約別請求書生成
async function generateInvoiceForContract(
  contract: Contract, 
  period: DateRange
): Promise<void> {
  // 1. 利用量データ取得
  const usageData = await getUsageDataForContract(contract.id, period)
  
  // 2. 請求金額計算
  const billingAmount = calculateBillingAmount(contract, usageData)
  
  // 3. 請求書データ作成
  const invoiceData = {
    contractId: contract.id,
    invoiceNumber: generateInvoiceNumber(contract.companyId, period),
    billingPeriodStart: period.start,
    billingPeriodEnd: period.end,
    issueDate: new Date(),
    dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30日後
    subtotal: billingAmount.subtotal,
    taxAmount: billingAmount.tax,
    totalAmount: billingAmount.total,
    usageDetails: usageData,
    createdBy: 'system'
  }
  
  // 4. 請求書保存
  await invoiceRepository.create(invoiceData)
  
  // 5. PDF生成
  await generateInvoicePDF(invoiceData)
}

// 請求金額計算
function calculateBillingAmount(
  contract: Contract, 
  usageData: UsageData
): BillingAmount {
  const plan = contract.contractPlan
  
  let subtotal = plan.basePrice
  
  // ユーザー数課金
  if (usageData.maxUsers > plan.maxUsers) {
    const extraUsers = usageData.maxUsers - plan.maxUsers
    subtotal += extraUsers * plan.pricePerUser
  }
  
  // エンジニア数課金
  if (usageData.maxEngineers > plan.maxEngineers) {
    const extraEngineers = usageData.maxEngineers - plan.maxEngineers
    subtotal += extraEngineers * plan.pricePerEngineer
  }
  
  const tax = Math.floor(subtotal * 0.1) // 消費税10%
  const total = subtotal + tax
  
  return { subtotal, tax, total }
}
```

### 4.2 月次レポート生成バッチ
```
バッチID: MONTHLY_002
実行時間: 毎月2日 07:00
概要: 月次利用統計レポート生成
```

#### 処理内容
```typescript
interface MonthlyReportJob {
  name: 'monthly-report-generation'
  schedule: '0 7 2 * *' // 毎月2日 07:00
}

async function generateMonthlyReports() {
  const lastMonth = getLastMonthDateRange()
  
  try {
    // 1. 企業別レポート生成
    await generateCompanyReports(lastMonth)
    
    // 2. システム全体レポート生成
    await generateSystemReport(lastMonth)
    
    // 3. エンジニア活動レポート生成
    await generateEngineerActivityReport(lastMonth)
    
    // 4. 売上レポート生成（管理者向け）
    await generateRevenueReport(lastMonth)
    
    logger.info('Monthly reports generated', { period: lastMonth })
    
  } catch (error) {
    logger.error('Monthly report generation failed', { error })
    throw error
  }
}

// 企業別レポート生成
async function generateCompanyReports(period: DateRange): Promise<void> {
  const companies = await companyRepository.findActiveCompanies()
  
  for (const company of companies) {
    const reportData = await generateCompanyReportData(company.id, period)
    
    // PDF生成
    const pdfBuffer = await generateReportPDF(reportData, 'company-monthly')
    
    // レポート保存
    await fileRepository.save({
      fileName: `monthly_report_${company.id}_${period.month}.pdf`,
      content: pdfBuffer,
      companyId: company.id
    })
    
    // メール送信
    await sendReportEmail(company, pdfBuffer, period)
  }
}
```

## 5. リアルタイム処理

### 5.1 定期アプローチ配信処理
```
処理ID: REALTIME_001
実行間隔: 企業設定による（日次、週次、月次）
概要: 企業が設定した定期アプローチの自動配信
```

#### 処理内容
```typescript
interface PeriodicApproachJob {
  name: 'periodic-approach-delivery'
  // 動的スケジュール（企業設定による）
}

async function processPeriodicApproaches() {
  try {
    // 1. 配信対象の定期アプローチ取得
    const dueApproaches = await getApproachesDueForDelivery()
    
    // 2. 各アプローチ処理
    for (const approach of dueApproaches) {
      await processPeriodicApproach(approach)
    }
    
    logger.info('Periodic approaches processed', { 
      count: dueApproaches.length 
    })
    
  } catch (error) {
    logger.error('Periodic approach processing failed', { error })
    throw error
  }
}

async function processPeriodicApproach(approach: PeriodicApproach): Promise<void> {
  try {
    // 1. 送信対象エンジニア取得（最新状況）
    const availableEngineers = await getAvailableEngineers(approach.criteria)
    
    // 2. 除外エンジニアフィルタリング
    const filteredEngineers = await filterExcludedEngineers(
      availableEngineers, 
      approach.companyId
    )
    
    // 3. アプローチメール生成・送信
    if (filteredEngineers.length > 0) {
      await sendPeriodicApproachEmail(approach, filteredEngineers)
      
      // 4. 次回配信日設定
      await updateNextDeliveryDate(approach)
    }
    
  } catch (error) {
    logger.error('Periodic approach processing failed', { 
      approachId: approach.id, 
      error 
    })
  }
}
```

### 5.2 通知配信処理
```
処理ID: REALTIME_002
実行間隔: キューベース（即座実行）
概要: システム内通知とメール通知の配信
```

#### 処理内容
```typescript
interface NotificationJob {
  name: 'notification-delivery'
  type: 'queue' // キューベース処理
}

// 通知配信ワーカー
async function processNotifications(job: NotificationJobData) {
  const { notification } = job
  
  try {
    switch (notification.type) {
      case 'email':
        await sendEmailNotification(notification)
        break
      case 'in-app':
        await sendInAppNotification(notification)
        break
      case 'sms':
        await sendSMSNotification(notification)
        break
      default:
        throw new Error(`Unknown notification type: ${notification.type}`)
    }
    
    // 配信ログ記録
    await notificationLogRepository.create({
      notificationId: notification.id,
      status: 'delivered',
      deliveredAt: new Date()
    })
    
  } catch (error) {
    // エラーログ記録
    await notificationLogRepository.create({
      notificationId: notification.id,
      status: 'failed',
      errorMessage: error.message,
      attemptedAt: new Date()
    })
    
    throw error
  }
}

// メール通知送信
async function sendEmailNotification(notification: EmailNotification): Promise<void> {
  const emailData = {
    to: notification.recipient,
    subject: notification.subject,
    html: await renderEmailTemplate(notification.template, notification.data),
    attachments: notification.attachments
  }
  
  await emailService.send(emailData)
}
```

## 6. エラーハンドリング・リトライ機構

### 6.1 リトライ設定
```typescript
interface RetryConfig {
  maxAttempts: number
  backoffStrategy: 'fixed' | 'exponential' | 'linear'
  baseDelay: number
  maxDelay: number
}

const jobRetryConfigs: Record<string, RetryConfig> = {
  'engineer-status-update': {
    maxAttempts: 3,
    backoffStrategy: 'exponential',
    baseDelay: 5000,
    maxDelay: 60000
  },
  'daily-backup': {
    maxAttempts: 2,
    backoffStrategy: 'fixed',
    baseDelay: 30000,
    maxDelay: 30000
  },
  'invoice-generation': {
    maxAttempts: 5,
    backoffStrategy: 'linear',
    baseDelay: 10000,
    maxDelay: 300000
  }
}

// リトライ処理実装
async function executeWithRetry<T>(
  jobName: string,
  operation: () => Promise<T>
): Promise<T> {
  const config = jobRetryConfigs[jobName]
  let lastError: Error
  
  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      return await operation()
    } catch (error) {
      lastError = error
      
      if (attempt === config.maxAttempts) {
        break
      }
      
      const delay = calculateDelay(config, attempt)
      logger.warn(`Job ${jobName} failed, retrying in ${delay}ms`, { 
        attempt, 
        error: error.message 
      })
      
      await sleep(delay)
    }
  }
  
  throw lastError
}
```

### 6.2 デッドレターキュー
```typescript
// 失敗したジョブの処理
interface DeadLetterJob {
  originalJob: JobData
  failureReason: string
  failedAt: Date
  attemptCount: number
}

async function handleDeadLetterJob(deadJob: DeadLetterJob) {
  // 1. 管理者通知
  await notifyAdministrators({
    type: 'job-failure',
    jobName: deadJob.originalJob.name,
    failureReason: deadJob.failureReason,
    metadata: deadJob
  })
  
  // 2. 失敗ジョブログ保存
  await deadLetterRepository.create(deadJob)
  
  // 3. 重要ジョブの場合は手動復旧通知
  if (isCriticalJob(deadJob.originalJob.name)) {
    await alertOperations(deadJob)
  }
}
```

## 7. 監視・ログ設計

### 7.1 メトリクス監視
```typescript
// Prometheus メトリクス定義
const batchMetrics = {
  jobDuration: new prometheus.Histogram({
    name: 'batch_job_duration_seconds',
    help: 'Duration of batch jobs in seconds',
    labelNames: ['job_name', 'status']
  }),
  
  jobCount: new prometheus.Counter({
    name: 'batch_job_total',
    help: 'Total number of batch jobs executed',
    labelNames: ['job_name', 'status']
  }),
  
  queueSize: new prometheus.Gauge({
    name: 'batch_queue_size',
    help: 'Current size of job queue',
    labelNames: ['queue_name']
  })
}

// メトリクス記録
function recordJobMetrics(jobName: string, duration: number, status: 'success' | 'failure') {
  batchMetrics.jobDuration.observe({ job_name: jobName, status }, duration)
  batchMetrics.jobCount.inc({ job_name: jobName, status })
}
```

### 7.2 ログ設計
```typescript
// 構造化ログフォーマット
interface BatchLogEntry {
  timestamp: string
  level: 'info' | 'warn' | 'error' | 'debug'
  jobName: string
  jobId: string
  message: string
  metadata?: Record<string, any>
  duration?: number
  error?: string
}

// ログ出力例
logger.info('Batch job started', {
  jobName: 'engineer-status-update',
  jobId: 'uuid-job-id',
  scheduledTime: '02:00:00',
  metadata: {
    targetCount: 150
  }
})
```

## 8. 運用・管理機能

### 8.1 バッチ管理API
```typescript
// バッチ手動実行API
POST /admin/batch/jobs/{jobName}/execute
{
  "parameters": {
    "dryRun": false,
    "targetDate": "2024-01-01"
  }
}

// バッチ状態確認API
GET /admin/batch/jobs/{jobName}/status

// バッチ履歴取得API
GET /admin/batch/jobs/{jobName}/history?limit=100
```

### 8.2 アラート設定
```typescript
const alertConditions = {
  jobFailure: {
    condition: 'job_status == "failed"',
    severity: 'critical',
    recipients: ['admin@company.com', 'ops@company.com']
  },
  longRunningJob: {
    condition: 'job_duration > 3600', // 1時間以上
    severity: 'warning',
    recipients: ['ops@company.com']
  },
  queueBacklog: {
    condition: 'queue_size > 1000',
    severity: 'warning',
    recipients: ['ops@company.com']
  }
}
```

このバッチ処理設計により、システムの自動化と安定運用を実現できます。