    - name: Run integration tests
      run: |
        cd backend && npm run test:integration
      env:
        DATABASE_URL: postgresql://skillsheet:password@postgres:5432/skillsheet_test
        REDIS_URL: redis://redis:6379

  e2e-tests:
    needs: integration-tests
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install Playwright
      run: npx playwright install
    
    - name: Start test environment
      run: |
        docker-compose -f docker-compose.test.yml up -d
        sleep 30
    
    - name: Run E2E tests
      run: npx playwright test
    
    - name: Upload test artifacts
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: e2e-test-results
        path: |
          test-results/
          playwright-report/
```

### 6.2 カバレッジ計測・レポート

#### カバレッジ設定
```typescript
// jest.config.coverage.js
module.exports = {
  ...require('./jest.config.js'),
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: [
    'text',
    'lcov',
    'html',
    'json-summary'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    },
    './src/services/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    },
    './src/controllers/': {
      branches: 85,
      functions: 85,
      lines: 85,
      statements: 85
    }
  },
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/coverage/',
    '/__tests__/',
    '/src/types/',
    '/src/migrations/',
    '/src/seeds/',
    '.d.ts'
  ]
};
```

#### カバレッジレポート生成
```bash
# scripts/generate-coverage-report.sh
#!/bin/bash

echo "📊 カバレッジレポート生成中..."

# バックエンドカバレッジ
cd backend
npm run test:coverage
npm run test:integration:coverage

# フロントエンドカバレッジ
cd ../frontend
npm run test:coverage

# 統合レポート生成
cd ..
mkdir -p reports/coverage

# バックエンドレポートをコピー
cp -r backend/coverage reports/coverage/backend

# フロントエンドレポートをコピー
cp -r frontend/coverage reports/coverage/frontend

# 統合HTMLレポート生成
cat > reports/coverage/index.html << 'EOL'
<!DOCTYPE html>
<html>
<head>
    <title>エンジニアスキルシート管理システム - カバレッジレポート</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .coverage-container { display: flex; gap: 20px; }
        .coverage-section { flex: 1; border: 1px solid #ddd; padding: 20px; }
        .metric { display: flex; justify-content: space-between; margin: 10px 0; }
        .high { color: green; }
        .medium { color: orange; }
        .low { color: red; }
    </style>
</head>
<body>
    <h1>カバレッジレポート</h1>
    <div class="coverage-container">
        <div class="coverage-section">
            <h2>バックエンド</h2>
            <iframe src="backend/lcov-report/index.html" width="100%" height="400"></iframe>
        </div>
        <div class="coverage-section">
            <h2>フロントエンド</h2>
            <iframe src="frontend/lcov-report/index.html" width="100%" height="400"></iframe>
        </div>
    </div>
</body>
</html>
EOL

echo "✅ カバレッジレポート生成完了"
echo "📂 レポート場所: reports/coverage/index.html"
```

## 7. パフォーマンステスト設計

### 7.1 負荷テスト設計

#### Artillery設定
```yaml
# tests/performance/load-test.yml
config:
  target: 'http://localhost:8000'
  phases:
    # ウォームアップフェーズ
    - duration: 60
      arrivalRate: 1
      name: "Warm up"
    # 段階的負荷増加
    - duration: 300
      arrivalRate: 5
      rampTo: 25
      name: "Ramp up load"
    # 最大負荷維持
    - duration: 600
      arrivalRate: 25
      name: "Sustained load"
    # 負荷減少
    - duration: 300
      arrivalRate: 25
      rampTo: 5
      name: "Ramp down"
  defaults:
    headers:
      Content-Type: 'application/json'
  processor: './test-functions.js'

scenarios:
  # ログインシナリオ
  - name: "User Authentication"
    weight: 20
    flow:
      - post:
          url: "/api/v1/auth/login"
          json:
            email: "{{ $randomEmail() }}"
            password: "testpassword123"
          capture:
            - json: "$.data.tokens.accessToken"
              as: "accessToken"
      - think: 5

  # エンジニア一覧取得シナリオ
  - name: "Engineer List"
    weight: 30
    flow:
      - function: "setAuthHeader"
      - get:
          url: "/api/v1/engineers"
          headers:
            Authorization: "Bearer {{ accessToken }}"
      - think: 3

  # エンジニア検索シナリオ
  - name: "Engineer Search"
    weight: 25
    flow:
      - function: "setAuthHeader"
      - post:
          url: "/api/v1/search/engineers"
          headers:
            Authorization: "Bearer {{ accessToken }}"
          json:
            filters:
              skills:
                programmingLanguages: ["JavaScript", "React"]
              status: ["waiting"]
      - think: 5

  # スキルシート更新シナリオ
  - name: "Skill Sheet Update"
    weight: 15
    flow:
      - function: "setAuthHeader"
      - put:
          url: "/api/v1/engineers/{{ $randomEngineerId() }}/skill-sheet"
          headers:
            Authorization: "Bearer {{ accessToken }}"
          json:
            summary: "Updated skill summary"
            programmingLanguages:
              - name: "JavaScript"
                level: 4
                experienceYears: 5
      - think: 10

  # アプローチ作成シナリオ
  - name: "Create Approach"
    weight: 10
    flow:
      - function: "setAuthHeader"
      - post:
          url: "/api/v1/approaches"
          headers:
            Authorization: "Bearer {{ accessToken }}"
          json:
            approachType: "manual"
            targetCompanyId: "{{ $randomCompanyId() }}"
            targetEngineers: ["{{ $randomEngineerId() }}"]
            projectDetails: "Load test project"
            messageContent: "This is a load test message"
      - think: 15
```

#### パフォーマンステスト実行スクリプト
```javascript
// tests/performance/test-functions.js
const { faker } = require('@faker-js/faker');

// テスト用ユーザーのアクセストークン
const testTokens = [
  'test_token_1',
  'test_token_2', 
  'test_token_3'
];

// ランダムなエンジニアID
const engineerIds = [
  'eng_001', 'eng_002', 'eng_003', 'eng_004', 'eng_005'
];

// ランダムな企業ID
const companyIds = [
  'company_001', 'company_002', 'company_003'
];

module.exports = {
  setAuthHeader: function(context, events, done) {
    context.vars.accessToken = testTokens[Math.floor(Math.random() * testTokens.length)];
    return done();
  },

  $randomEmail: function() {
    return faker.internet.email();
  },

  $randomEngineerId: function() {
    return engineerIds[Math.floor(Math.random() * engineerIds.length)];
  },

  $randomCompanyId: function() {
    return companyIds[Math.floor(Math.random() * companyIds.length)];
  }
};
```

### 7.2 パフォーマンス計測

#### メトリクス取得設定
```typescript
// src/middleware/performance.ts
import { Request, Response, NextFunction } from 'express';
import { performance } from 'perf_hooks';

interface PerformanceMetrics {
  timestamp: Date;
  method: string;
  url: string;
  statusCode: number;
  responseTime: number;
  memoryUsage: NodeJS.MemoryUsage;
  cpuUsage: NodeJS.CpuUsage;
}

const performanceMetrics: PerformanceMetrics[] = [];

export const performanceMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const startTime = performance.now();
  const startCpuUsage = process.cpuUsage();

  res.on('finish', () => {
    const endTime = performance.now();
    const responseTime = endTime - startTime;
    const cpuUsage = process.cpuUsage(startCpuUsage);

    const metrics: PerformanceMetrics = {
      timestamp: new Date(),
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      responseTime,
      memoryUsage: process.memoryUsage(),
      cpuUsage
    };

    performanceMetrics.push(metrics);

    // パフォーマンスアラート
    if (responseTime > 1000) {
      console.warn(`Slow response detected: ${req.method} ${req.originalUrl} - ${responseTime}ms`);
    }

    // メトリクス配列サイズ制限
    if (performanceMetrics.length > 10000) {
      performanceMetrics.splice(0, 5000);
    }
  });

  next();
};

export const getPerformanceReport = () => {
  const totalRequests = performanceMetrics.length;
  if (totalRequests === 0) return null;

  const responseTimes = performanceMetrics.map(m => m.responseTime);
  const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / totalRequests;
  
  responseTimes.sort((a, b) => a - b);
  const p95ResponseTime = responseTimes[Math.floor(totalRequests * 0.95)];
  const p99ResponseTime = responseTimes[Math.floor(totalRequests * 0.99)];

  const statusCodes = performanceMetrics.reduce((acc, m) => {
    acc[m.statusCode] = (acc[m.statusCode] || 0) + 1;
    return acc;
  }, {} as Record<number, number>);

  const errorRate = (statusCodes[500] || 0) / totalRequests * 100;

  return {
    totalRequests,
    avgResponseTime: Math.round(avgResponseTime),
    p95ResponseTime: Math.round(p95ResponseTime),
    p99ResponseTime: Math.round(p99ResponseTime),
    errorRate: Math.round(errorRate * 100) / 100,
    statusCodes,
    period: {
      start: performanceMetrics[0].timestamp,
      end: performanceMetrics[totalRequests - 1].timestamp
    }
  };
};
```

## 8. セキュリティテスト設計

### 8.1 脆弱性テスト

#### OWASP ZAP自動スキャン
```yaml
# tests/security/zap-scan.yml
version: '3.8'

services:
  zap:
    image: owasp/zap2docker-stable
    command: >
      zap-full-scan.py 
      -t http://host.docker.internal:3000
      -r zap-report.html
      -x zap-report.xml
      -J zap-report.json
    volumes:
      - ./reports:/zap/wrk
    network_mode: host
    depends_on:
      - app

  app:
    image: skillsheet/app:test
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=test
```

#### セキュリティテストスクリプト
```bash
#!/bin/bash
# tests/security/run-security-tests.sh

echo "🔒 セキュリティテスト実行中..."

# 1. SQLインジェクションテスト
echo "🛡️ SQLインジェクションテストを実行中..."
sqlmap -u "http://localhost:8000/api/v1/engineers" \
       --cookie="session=test_session" \
       --level=3 \
       --risk=2 \
       --batch \
       --output-dir=./reports/sqlmap

# 2. XSSテスト
echo "🛡️ XSSテストを実行中..."
node tests/security/xss-test.js

# 3. CSRFテスト
echo "🛡️ CSRFテストを実行中..."
node tests/security/csrf-test.js

# 4. 認証バイパステスト
echo "🛡️ 認証バイパステストを実行中..."
node tests/security/auth-bypass-test.js

# 5. ブルートフォース攻撃テスト
echo "🛡️ ブルートフォース攻撃テストを実行中..."
node tests/security/brute-force-test.js

echo "✅ セキュリティテスト完了"
```

#### XSSテスト実装
```typescript
// tests/security/xss-test.js
import axios from 'axios';

const baseURL = 'http://localhost:8000/api/v1';

const xssPayloads = [
  '<script>alert("XSS")</script>',
  '"><script>alert("XSS")</script>',
  "';alert('XSS');//",
  '<img src="x" onerror="alert(\'XSS\')">',
  'javascript:alert("XSS")',
  '<svg onload="alert(\'XSS\')">',
  '${alert("XSS")}',
  '<iframe src="javascript:alert(\'XSS\')"></iframe>'
];

const testEndpoints = [
  { method: 'POST', url: '/engineers', field: 'name' },
  { method: 'PUT', url: '/engineers/test-id/skill-sheet', field: 'summary' },
  { method: 'POST', url: '/approaches', field: 'messageContent' },
  { method: 'POST', url: '/search/engineers', field: 'search' }
];

async function runXSSTests() {
  console.log('XSSテスト開始...');
  let vulnerabilitiesFound = 0;

  for (const endpoint of testEndpoints) {
    for (const payload of xssPayloads) {
      try {
        const data = { [endpoint.field]: payload };
        
        const response = await axios({
          method: endpoint.method,
          url: baseURL + endpoint.url,
          data,
          headers: {
            'Authorization': 'Bearer test-token',
            'Content-Type': 'application/json'
          }
        });

        // レスポンスにサニタイズされていないペイロードが含まれていないかチェック
        if (response.data && JSON.stringify(response.data).includes(payload)) {
          console.log(`🚨 XSS脆弱性発見: ${endpoint.method} ${endpoint.url} - Field: ${endpoint.field}`);
          vulnerabilitiesFound++;
        }

      } catch (error) {
        // エラーレスポンスもチェック
        if (error.response && JSON.stringify(error.response.data).includes(payload)) {
          console.log(`🚨 XSS脆弱性発見（エラーレスポンス）: ${endpoint.method} ${endpoint.url}`);
          vulnerabilitiesFound++;
        }
      }
    }
  }

  if (vulnerabilitiesFound === 0) {
    console.log('✅ XSS脆弱性は発見されませんでした');
  } else {
    console.log(`❌ ${vulnerabilitiesFound}個のXSS脆弱性が発見されました`);
    process.exit(1);
  }
}

runXSSTests().catch(console.error);
```

## 9. テストデータ管理

### 9.1 テストデータファクトリー

```typescript
// tests/helpers/factories.ts
import { faker } from '@faker-js/faker';

export class UserFactory {
  static create(overrides?: Partial<User>): User {
    return {
      id: faker.string.uuid(),
      name: faker.person.fullName(),
      email: faker.internet.email(),
      passwordHash: '$2b$10$hashedPassword',
      companyId: faker.string.uuid(),
      roles: ['engineer'],
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }

  static createAdmin(overrides?: Partial<User>): User {
    return this.create({
      roles: ['admin'],
      ...overrides
    });
  }

  static createSales(overrides?: Partial<User>): User {
    return this.create({
      roles: ['sales'],
      ...overrides
    });
  }
}

export class EngineerFactory {
  static create(overrides?: Partial<Engineer>): Engineer {
    return {
      id: faker.string.uuid(),
      name: faker.person.fullName(),
      email: faker.internet.email(),
      engineerType: 'employee',
      currentStatus: 'working',
      availableDate: faker.date.future(),
      nearestStation: faker.location.city() + '駅',
      githubUrl: faker.internet.url(),
      companyId: faker.string.uuid(),
      isPublic: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }

  static createWaiting(overrides?: Partial<Engineer>): Engineer {
    return this.create({
      currentStatus: 'waiting',
      availableDate: faker.date.soon(),
      ...overrides
    });
  }
}

export class SkillSheetFactory {
  static create(overrides?: Partial<SkillSheet>): SkillSheet {
    return {
      id: faker.string.uuid(),
      engineerId: faker.string.uuid(),
      summary: faker.lorem.paragraphs(2),
      totalExperienceYears: faker.number.int({ min: 1, max: 20 }),
      programmingLanguages: [
        {
          name: 'JavaScript',
          level: faker.number.int({ min: 1, max: 5 }),
          experienceYears: faker.number.int({ min: 1, max: 10 })
        }
      ],
      frameworks: [
        {
          name: 'React',
          level: faker.number.int({ min: 1, max: 5 }),
          experienceYears: faker.number.int({ min: 1, max: 5 })
        }
      ],
      isCompleted: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides
    };
  }
}

export class TestDataBuilder {
  static async createTestUser(): Promise<{ user: User; token: string }> {
    const user = UserFactory.create();
    const token = jwt.sign(
      { userId: user.id, companyId: user.companyId },
      'test-secret',
      { expiresIn: '1h' }
    );
    
    return { user, token };
  }

  static async createTestCompanyWithUsers(): Promise<{
    company: Company;
    admin: User;
    sales: User;
    engineers: Engineer[];
  }> {
    const company = CompanyFactory.create();
    
    const admin = UserFactory.createAdmin({ companyId: company.id });
    const sales = UserFactory.createSales({ companyId: company.id });
    
    const engineers = Array.from({ length: 5 }, () =>
      EngineerFactory.create({ companyId: company.id })
    );

    return { company, admin, sales, engineers };
  }
}
```

### 9.2 テストデータベースシード

```typescript
// tests/helpers/seed.ts
export class TestSeeder {
  static async seedDatabase(): Promise<void> {
    // 企業データ
    const companies = await Promise.all([
      this.createCompany('SES企業A', 'ses'),
      this.createCompany('SES企業B', 'ses'),
      this.createCompany('クライアント企業A', 'client'),
      this.createCompany('クライアント企業B', 'client')
    ]);

    // ユーザーデータ
    for (const company of companies) {
      if (company.companyType === 'ses') {
        await this.createUsersForSESCompany(company);
      } else {
        await this.createUsersForClientCompany(company);
      }
    }

    // スキルマスターデータ
    await this.createSkillMasterData();
  }

  private static async createCompany(name: string, type: string): Promise<Company> {
    return await companyRepository.create({
      name,
      companyType: type,
      emailDomain: name.toLowerCase().replace(/\s+/g, '') + '.com',
      maxEngineers: type === 'ses' ? 100 : 0,
      isActive: true
    });
  }

  private static async createUsersForSESCompany(company: Company): Promise<void> {
    // 管理者
    const admin = await userRepository.create(
      UserFactory.createAdmin({
        companyId: company.id,
        email: `admin@${company.emailDomain}`
      })
    );

    // 営業担当者
    const sales = await userRepository.create(
      UserFactory.createSales({
        companyId: company.id,
        email: `sales@${company.emailDomain}`
      })
    );

    // エンジニア
    const engineers = await Promise.all(
      Array.from({ length: 10 }, (_, i) =>
        # 詳細なテスト設計書 - エンジニアスキルシート管理システム

## 1. テスト戦略概要

### 1.1 テスト方針
| 項目 | 内容 |
|------|------|
| テスト手法 | 自動テスト中心、手動テスト補完 |
| テスト範囲 | 単体→結合→システム→受入テスト |
| カバレッジ目標 | コード：80%以上、機能：100% |
| テスト環境 | 独立したテスト環境で実行 |
| CI/CD統合 | 全自動テストをパイプラインに統合 |

### 1.2 テストピラミッド
```
       /\
      /  \
     / E2E \ (10%)
    /______\
   /        \
  /   統合   \ (20%)
 /__________\
/            \
/    単体     \ (70%)
/______________\
```

## 2. 単体テスト設計

### 2.1 バックエンド単体テスト

#### 2.1.1 テストフレームワーク構成
```typescript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.test.ts'],
  collectCoverageFrom: [
    'src/**/*.{ts,js}',
    '!src/**/*.d.ts',
    '!src/types/**',
    '!src/migrations/**',
    '!src/seeds/**'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts'],
  testTimeout: 30000
};
```

#### 2.1.2 エンジニア管理サービスのテスト
```typescript
// src/__tests__/services/EngineerService.test.ts
import { EngineerService } from '../../services/EngineerService';
import { EngineerRepository } from '../../repositories/EngineerRepository';
import { SkillSheetRepository } from '../../repositories/SkillSheetRepository';
import { ValidationError, NotFoundError } from '../../errors';

// モックの設定
jest.mock('../../repositories/EngineerRepository');
jest.mock('../../repositories/SkillSheetRepository');

describe('EngineerService', () => {
  let engineerService: EngineerService;
  let mockEngineerRepository: jest.Mocked<EngineerRepository>;
  let mockSkillSheetRepository: jest.Mocked<SkillSheetRepository>;

  beforeEach(() => {
    mockEngineerRepository = new EngineerRepository() as jest.Mocked<EngineerRepository>;
    mockSkillSheetRepository = new SkillSheetRepository() as jest.Mocked<SkillSheetRepository>;
    engineerService = new EngineerService(mockEngineerRepository, mockSkillSheetRepository);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createEngineer', () => {
    const validEngineerData = {
      name: '田中太郎',
      email: 'tanaka@company.com',
      engineerType: 'employee' as const,
      companyId: 'company_123',
      phone: '03-1234-5678',
      nearestStation: '新宿駅'
    };

    it('正常なエンジニアデータで作成が成功すること', async () => {
      // Arrange
      const mockCreatedEngineer = { id: 'eng_123', ...validEngineerData };
      mockEngineerRepository.create.mockResolvedValue(mockCreatedEngineer);

      // Act
      const result = await engineerService.createEngineer(validEngineerData);

      // Assert
      expect(result).toEqual(mockCreatedEngineer);
      expect(mockEngineerRepository.create).toHaveBeenCalledWith(validEngineerData);
    });

    it('重複メールアドレスでエラーが発生すること', async () => {
      // Arrange
      mockEngineerRepository.findByEmail.mockResolvedValue({ id: 'existing_eng' } as any);

      // Act & Assert
      await expect(engineerService.createEngineer(validEngineerData))
        .rejects.toThrow(ValidationError);
    });

    it('無効なメールアドレス形式でバリデーションエラーが発生すること', async () => {
      // Arrange
      const invalidData = { ...validEngineerData, email: 'invalid-email' };

      // Act & Assert
      await expect(engineerService.createEngineer(invalidData))
        .rejects.toThrow(ValidationError);
    });

    it('企業の最大エンジニア数を超過した場合エラーが発生すること', async () => {
      // Arrange
      mockEngineerRepository.countByCompanyId.mockResolvedValue(100);
      mockEngineerRepository.findByEmail.mockResolvedValue(null);

      // Act & Assert
      await expect(engineerService.createEngineer(validEngineerData))
        .rejects.toThrow(ValidationError);
    });
  });

  describe('updateEngineerStatus', () => {
    it('待機ステータスに更新できること', async () => {
      // Arrange
      const engineerId = 'eng_123';
      const newStatus = 'waiting';
      const mockEngineer = { id: engineerId, currentStatus: 'working' };
      mockEngineerRepository.findById.mockResolvedValue(mockEngineer as any);
      mockEngineerRepository.updateStatus.mockResolvedValue({ ...mockEngineer, currentStatus: newStatus } as any);

      // Act
      const result = await engineerService.updateEngineerStatus(engineerId, newStatus);

      // Assert
      expect(result.currentStatus).toBe(newStatus);
      expect(mockEngineerRepository.updateStatus).toHaveBeenCalledWith(engineerId, newStatus);
    });

    it('存在しないエンジニアIDでNotFoundErrorが発生すること', async () => {
      // Arrange
      mockEngineerRepository.findById.mockResolvedValue(null);

      // Act & Assert
      await expect(engineerService.updateEngineerStatus('invalid_id', 'waiting'))
        .rejects.toThrow(NotFoundError);
    });
  });

  describe('searchEngineers', () => {
    const searchCriteria = {
      skills: ['JavaScript', 'React'],
      experienceYears: { min: 3, max: 10 },
      status: ['waiting'],
      companyId: 'company_123'
    };

    it('検索条件に合致するエンジニアが取得できること', async () => {
      // Arrange
      const mockEngineers = [
        { id: 'eng_1', name: '田中太郎', skills: ['JavaScript', 'React'] },
        { id: 'eng_2', name: '佐藤花子', skills: ['JavaScript', 'Vue.js'] }
      ];
      mockEngineerRepository.search.mockResolvedValue(mockEngineers as any);

      // Act
      const result = await engineerService.searchEngineers(searchCriteria);

      // Assert
      expect(result).toEqual(mockEngineers);
      expect(mockEngineerRepository.search).toHaveBeenCalledWith(searchCriteria);
    });

    it('条件に合致するエンジニアがいない場合空配列が返されること', async () => {
      // Arrange
      mockEngineerRepository.search.mockResolvedValue([]);

      // Act
      const result = await engineerService.searchEngineers(searchCriteria);

      // Assert
      expect(result).toEqual([]);
    });
  });
});
```

#### 2.1.3 認証サービスのテスト
```typescript
// src/__tests__/services/AuthService.test.ts
import { AuthService } from '../../services/AuthService';
import { UserRepository } from '../../repositories/UserRepository';
import { SessionManager } from '../../services/SessionManager';
import { MFAService } from '../../services/MFAService';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

jest.mock('../../repositories/UserRepository');
jest.mock('../../services/SessionManager');
jest.mock('../../services/MFAService');
jest.mock('bcrypt');
jest.mock('jsonwebtoken');

describe('AuthService', () => {
  let authService: AuthService;
  let mockUserRepository: jest.Mocked<UserRepository>;
  let mockSessionManager: jest.Mocked<SessionManager>;
  let mockMFAService: jest.Mocked<MFAService>;

  beforeEach(() => {
    mockUserRepository = new UserRepository() as jest.Mocked<UserRepository>;
    mockSessionManager = new SessionManager() as jest.Mocked<SessionManager>;
    mockMFAService = new MFAService() as jest.Mocked<MFAService>;
    authService = new AuthService(mockUserRepository, mockSessionManager, mockMFAService);
  });

  describe('login', () => {
    const loginData = {
      email: 'test@company.com',
      password: 'password123',
      ipAddress: '192.168.1.1',
      userAgent: 'Mozilla/5.0...'
    };

    const mockUser = {
      id: 'user_123',
      email: 'test@company.com',
      passwordHash: '$2b$10$hashedPassword',
      isActive: true,
      companyId: 'company_123',
      mfaEnabled: false,
      failedLoginCount: 0
    };

    it('正常なログインができること', async () => {
      // Arrange
      mockUserRepository.findByEmail.mockResolvedValue(mockUser as any);
      (bcrypt.compare as jest.Mock).mockResolvedValue(true);
      mockSessionManager.createSession.mockResolvedValue({ sessionId: 'session_123' } as any);
      (jwt.sign as jest.Mock).mockReturnValue('jwt_token');

      // Act
      const result = await authService.login(loginData);

      // Assert
      expect(result).toEqual({
        user: expect.objectContaining({ id: 'user_123' }),
        tokens: expect.objectContaining({ accessToken: 'jwt_token' })
      });
      expect(mockUserRepository.resetFailedLoginCount).toHaveBeenCalledWith('user_123');
    });

    it('パスワードが間違っている場合エラーが発生すること', async () => {
      // Arrange
      mockUserRepository.findByEmail.mockResolvedValue(mockUser as any);
      (bcrypt.compare as jest.Mock).mockResolvedValue(false);

      // Act & Assert
      await expect(authService.login(loginData))
        .rejects.toThrow('Invalid credentials');
      expect(mockUserRepository.incrementFailedLoginCount).toHaveBeenCalledWith('user_123');
    });

    it('MFA有効ユーザーは一時トークンが返されること', async () => {
      // Arrange
      const mfaUser = { ...mockUser, mfaEnabled: true };
      mockUserRepository.findByEmail.mockResolvedValue(mfaUser as any);
      (bcrypt.compare as jest.Mock).mockResolvedValue(true);

      // Act
      const result = await authService.login(loginData);

      // Assert
      expect(result).toEqual({
        requireMFA: true,
        tempToken: expect.any(String),
        user: expect.objectContaining({ id: 'user_123' })
      });
    });

    it('アカウントロック中はエラーが発生すること', async () => {
      // Arrange
      const lockedUser = { 
        ...mockUser, 
        accountLockedUntil: new Date(Date.now() + 60000) // 1分後まで
      };
      mockUserRepository.findByEmail.mockResolvedValue(lockedUser as any);

      // Act & Assert
      await expect(authService.login(loginData))
        .rejects.toThrow('Account is locked');
    });
  });

  describe('verifyMFA', () => {
    const mfaData = {
      tempToken: 'temp_token_123',
      mfaCode: '123456',
      ipAddress: '192.168.1.1',
      userAgent: 'Mozilla/5.0...'
    };

    it('正しいMFAコードで認証が完了すること', async () => {
      // Arrange
      const mockUser = { id: 'user_123', mfaEnabled: true };
      (jwt.verify as jest.Mock).mockReturnValue({ userId: 'user_123' });
      mockUserRepository.findById.mockResolvedValue(mockUser as any);
      mockMFAService.verifyTOTP.mockResolvedValue(true);
      mockSessionManager.createSession.mockResolvedValue({ sessionId: 'session_123' } as any);
      (jwt.sign as jest.Mock).mockReturnValue('jwt_token');

      // Act
      const result = await authService.verifyMFA(mfaData);

      // Assert
      expect(result).toEqual({
        user: expect.objectContaining({ id: 'user_123' }),
        tokens: expect.objectContaining({ accessToken: 'jwt_token' })
      });
    });

    it('間違ったMFAコードでエラーが発生すること', async () => {
      // Arrange
      (jwt.verify as jest.Mock).mockReturnValue({ userId: 'user_123' });
      mockUserRepository.findById.mockResolvedValue({ id: 'user_123' } as any);
      mockMFAService.verifyTOTP.mockResolvedValue(false);

      // Act & Assert
      await expect(authService.verifyMFA(mfaData))
        .rejects.toThrow('Invalid MFA code');
    });
  });

  describe('validateToken', () => {
    it('有効なトークンで検証が成功すること', async () => {
      // Arrange
      const mockPayload = { userId: 'user_123', sessionId: 'session_123' };
      (jwt.verify as jest.Mock).mockReturnValue(mockPayload);
      mockSessionManager.validateSession.mockResolvedValue({ isValid: true } as any);

      // Act
      const result = await authService.validateToken('valid_token');

      // Assert
      expect(result).toEqual(mockPayload);
    });

    it('無効なトークンでエラーが発生すること', async () => {
      // Arrange
      (jwt.verify as jest.Mock).mockImplementation(() => {
        throw new Error('Invalid token');
      });

      // Act & Assert
      await expect(authService.validateToken('invalid_token'))
        .rejects.toThrow('Invalid token');
    });
  });
});
```

### 2.2 フロントエンド単体テスト

#### 2.2.1 Reactコンポーネントテスト
```typescript
// src/__tests__/components/EngineerList.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BrowserRouter } from 'react-router-dom';
import { EngineerList } from '../../components/EngineerList';
import * as engineerApi from '../../api/engineerApi';

// APIモック
jest.mock('../../api/engineerApi');
const mockedEngineerApi = engineerApi as jest.Mocked<typeof engineerApi>;

// テストヘルパー
const renderWithProviders = (component: React.ReactElement) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  });

  return render(
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>
        {component}
      </BrowserRouter>
    </QueryClientProvider>
  );
};

describe('EngineerList', () => {
  const mockEngineers = [
    {
      id: 'eng_1',
      name: '田中太郎',
      email: 'tanaka@company.com',
      currentStatus: 'waiting',
      skills: { programmingLanguages: [{ name: 'JavaScript', level: 4 }] },
      availableDate: '2024-02-01'
    },
    {
      id: 'eng_2',
      name: '佐藤花子',
      email: 'sato@company.com',
      currentStatus: 'working',
      skills: { programmingLanguages: [{ name: 'Python', level: 3 }] },
      availableDate: null
    }
  ];

  beforeEach(() => {
    mockedEngineerApi.getEngineers.mockResolvedValue({
      data: mockEngineers,
      meta: { pagination: { total: 2, page: 1, totalPages: 1 } }
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('エンジニア一覧が正しく表示されること', async () => {
    // Act
    renderWithProviders(<EngineerList />);

    // Assert
    await waitFor(() => {
      expect(screen.getByText('田中太郎')).toBeInTheDocument();
      expect(screen.getByText('佐藤花子')).toBeInTheDocument();
    });

    expect(screen.getByText('waiting')).toBeInTheDocument();
    expect(screen.getByText('working')).toBeInTheDocument();
  });

  it('検索フィルターが動作すること', async () => {
    // Arrange
    renderWithProviders(<EngineerList />);
    await waitFor(() => screen.getByText('田中太郎'));

    const searchInput = screen.getByPlaceholderText('エンジニアを検索');
    const statusFilter = screen.getByLabelText('ステータス');

    // Act
    fireEvent.change(searchInput, { target: { value: '田中' } });
    fireEvent.change(statusFilter, { target: { value: 'waiting' } });
    fireEvent.click(screen.getByRole('button', { name: '検索' }));

    // Assert
    await waitFor(() => {
      expect(mockedEngineerApi.getEngineers).toHaveBeenCalledWith({
        search: '田中',
        status: 'waiting',
        page: 1,
        limit: 20
      });
    });
  });

  it('エンジニア詳細ページに遷移できること', async () => {
    // Arrange
    renderWithProviders(<EngineerList />);
    await waitFor(() => screen.getByText('田中太郎'));

    // Act
    fireEvent.click(screen.getByText('田中太郎'));

    // Assert
    expect(window.location.pathname).toBe('/engineers/eng_1');
  });

  it('新規エンジニア登録ボタンが表示されること', async () => {
    // Arrange
    renderWithProviders(<EngineerList />);

    // Assert
    await waitFor(() => {
      expect(screen.getByRole('button', { name: '新規登録' })).toBeInTheDocument();
    });
  });

  it('ローディング状態が表示されること', () => {
    // Arrange
    mockedEngineerApi.getEngineers.mockImplementation(
      () => new Promise(resolve => setTimeout(resolve, 1000))
    );

    // Act
    renderWithProviders(<EngineerList />);

    // Assert
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
  });

  it('エラー状態が表示されること', async () => {
    // Arrange
    mockedEngineerApi.getEngineers.mockRejectedValue(new Error('Network Error'));

    // Act
    renderWithProviders(<EngineerList />);

    // Assert
    await waitFor(() => {
      expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument();
    });
  });
});
```

#### 2.2.2 カスタムフックテスト
```typescript
// src/__tests__/hooks/useAuth.test.ts
import { renderHook, act } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useAuth } from '../../hooks/useAuth';
import * as authApi from '../../api/authApi';

jest.mock('../../api/authApi');
const mockedAuthApi = authApi as jest.Mocked<typeof authApi>;

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  });
  
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useAuth', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  it('初期状態では未認証であること', () => {
    // Act
    const { result } = renderHook(() => useAuth(), { wrapper: createWrapper() });

    // Assert
    expect(result.current.isAuthenticated).toBe(false);
    expect(result.current.user).toBe(null);
  });

  it('ログインが成功すること', async () => {
    // Arrange
    const loginData = { email: 'test@company.com', password: 'password' };
    const mockResponse = {
      user: { id: 'user_123', name: 'Test User' },
      tokens: { accessToken: 'token123' }
    };
    mockedAuthApi.login.mockResolvedValue(mockResponse);

    const { result } = renderHook(() => useAuth(), { wrapper: createWrapper() });

    // Act
    await act(async () => {
      await result.current.login(loginData);
    });

    // Assert
    expect(result.current.isAuthenticated).toBe(true);
    expect(result.current.user).toEqual(mockResponse.user);
    expect(localStorage.getItem('accessToken')).toBe('token123');
  });

  it('ログインに失敗した場合エラーが設定されること', async () => {
    // Arrange
    const loginData = { email: 'test@company.com', password: 'wrong' };
    mockedAuthApi.login.mockRejectedValue(new Error('Invalid credentials'));

    const { result } = renderHook(() => useAuth(), { wrapper: createWrapper() });

    // Act
    await act(async () => {
      try {
        await result.current.login(loginData);
      } catch (error) {
        // エラーは期待される
      }
    });

    // Assert
    expect(result.current.isAuthenticated).toBe(false);
    expect(result.current.error).toBe('Invalid credentials');
  });

  it('ログアウトが正常に動作すること', async () => {
    // Arrange
    localStorage.setItem('accessToken', 'token123');
    const { result } = renderHook(() => useAuth(), { wrapper: createWrapper() });

    // 初期状態を認証済みにする
    await act(async () => {
      result.current.setUser({ id: 'user_123', name: 'Test User' } as any);
    });

    // Act
    await act(async () => {
      result.current.logout();
    });

    // Assert
    expect(result.current.isAuthenticated).toBe(false);
    expect(result.current.user).toBe(null);
    expect(localStorage.getItem('accessToken')).toBe(null);
  });
});
```

## 3. 結合テスト設計

### 3.1 API結合テスト

#### 3.1.1 テスト環境セットアップ
```typescript
// src/__tests__/integration/setup.ts
import { Pool } from 'pg';
import Redis from 'ioredis';
import app from '../../app';
import { setupDatabase, seedTestData } from './helpers/database';

export interface TestContext {
  dbPool: Pool;
  redis: Redis;
  app: any;
}

let testContext: TestContext;

export const setupIntegrationTests = async (): Promise<TestContext> => {
  // テスト用データベース接続
  const dbPool = new Pool({
    connectionString: process.env.TEST_DATABASE_URL,
    max: 5
  });

  // テスト用Redis接続
  const redis = new Redis(process.env.TEST_REDIS_URL);

  // データベーススキーマセットアップ
  await setupDatabase(dbPool);

  // テストデータの投入
  await seedTestData(dbPool);

  testContext = {
    dbPool,
    redis,
    app
  };

  return testContext;
};

export const cleanupIntegrationTests = async (): Promise<void> => {
  if (testContext) {
    await testContext.dbPool.end();
    await testContext.redis.quit();
  }
};

export const getTestContext = (): TestContext => testContext;

// Jest setup
beforeAll(async () => {
  await setupIntegrationTests();
}, 30000);

afterAll(async () => {
  await cleanupIntegrationTests();
}, 10000);

beforeEach(async () => {
  // 各テスト前にデータベースをクリーンアップ
  const { dbPool } = getTestContext();
  await dbPool.query('TRUNCATE TABLE engineers, users, skill_sheets, projects CASCADE');
  await seedTestData(dbPool);
});
```

#### 3.1.2 エンジニア管理API結合テスト
```typescript
// src/__tests__/integration/engineers.test.ts
import request from 'supertest';
import { getTestContext } from './setup';

describe('Engineers API Integration', () => {
  let authToken: string;
  let companyId: string;

  beforeEach(async () => {
    const { app } = getTestContext();
    
    // テスト用ユーザーでログイン
    const loginResponse = await request(app)
      .post('/api/v1/auth/login')
      .send({
        email: 'admin@testcompany.com',
        password: 'testpassword123'
      });

    authToken = loginResponse.body.data.tokens.accessToken;
    companyId = loginResponse.body.data.user.companyId;
  });

  describe('POST /api/v1/engineers', () => {
    const validEngineerData = {
      name: '新規エンジニア',
      email: 'newengineer@testcompany.com',
      engineerType: 'employee',
      nearestStation: '新宿駅',
      phone: '03-1234-5678'
    };

    it('正常なデータでエンジニア作成が成功すること', async () => {
      const { app } = getTestContext();

      const response = await request(app)
        .post('/api/v1/engineers')
        .set('Authorization', `Bearer ${authToken}`)
        .send(validEngineerData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toMatchObject({
        name: validEngineerData.name,
        email: validEngineerData.email,
        engineerType: validEngineerData.engineerType
      });
      expect(response.body.data.id).toBeDefined();
    });

    it('重複するメールアドレスでエラーが発生すること', async () => {
      const { app } = getTestContext();

      // 1回目の作成
      await request(app)
        .post('/api/v1/engineers')
        .set('Authorization', `Bearer ${authToken}`)
        .send(validEngineerData);

      // 2回目の作成（重複）
      const response = await request(app)
        .post('/api/v1/engineers')
        .set('Authorization', `Bearer ${authToken}`)
        .send(validEngineerData)
        .expect(409);

      expect(response.body.success).toBe(false);
      expect(response.body.error.code).toBe('DUPLICATE_EMAIL');
    });

    it('認証なしでアクセスできないこと', async () => {
      const { app } = getTestContext();

      const response = await request(app)
        .post('/api/v1/engineers')
        .send(validEngineerData)
        .expect(401);

      expect(response.body.success).toBe(false);
    });

    it('バリデーションエラーが適切に返されること', async () => {
      const { app } = getTestContext();
      const invalidData = { ...validEngineerData, email: 'invalid-email' };

      const response = await request(app)
        .post('/api/v1/engineers')
        .set('Authorization', `Bearer ${authToken}`)
        .send(invalidData)
        .expect(422);

      expect(response.body.success).toBe(false);
      expect(response.body.error.code).toBe('VALIDATION_ERROR');
      expect(response.body.error.details).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            field: 'email',
            code: 'INVALID_EMAIL_FORMAT'
          })
        ])
      );
    });
  });

  describe('GET /api/v1/engineers', () => {
    beforeEach(async () => {
      // テストデータを事前作成
      const { app } = getTestContext();
      
      await request(app)
        .post('/api/v1/engineers')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: 'テストエンジニア1',
          email: 'test1@testcompany.com',
          engineerType: 'employee',
          currentStatus: 'waiting'
        });

      await request(app)
        .post('/api/v1/engineers')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: 'テストエンジニア2',
          email: 'test2@testcompany.com',
          engineerType: 'employee',
          currentStatus: 'working'
        });
    });

    it('エンジニア一覧が取得できること', async () => {
      const { app } = getTestContext();

      const response = await request(app)
        .get('/api/v1/engineers')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(2);
      expect(response.body.meta.pagination.total).toBe(2);
    });

    it('ステータスフィルターが動作すること', async () => {
      const { app } = getTestContext();

      const response = await request(app)
        .get('/api/v1/engineers?status=waiting')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(1);
      expect(response.body.data[0].currentStatus).toBe('waiting');
    });

    it('ページネーションが動作すること', async () => {
      const { app } = getTestContext();

      const response = await request(app)
        .get('/api/v1/engineers?page=1&limit=1')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(1);
      expect(response.body.meta.pagination.page).toBe(1);
      expect(response.body.meta.pagination.hasNext).toBe(true);
    });
  });

  describe('PUT /api/v1/engineers/:id', () => {
    let engineerId: string;

    beforeEach(async () => {
      const { app } = getTestContext();
      
      const createResponse = await request(app)
        .post('/api/v1/engineers')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: '更新テストエンジニア',
          email: 'update@testcompany.com',
          engineerType: 'employee'
        });
      
      engineerId = createResponse.body.data.id;
    });

    it('エンジニア情報が更新できること', async () => {
      const { app } = getTestContext();
      const updateData = {
        name: '更新後エンジニア',
        nearestStation: '渋谷駅'
      };

      const response = await request(app)
        .put(`/api/v1/engineers/${engineerId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(updateData)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.name).toBe(updateData.name);
      expect(response.body.data.nearestStation).toBe(updateData.nearestStation);
    });

    it('存在しないエンジニアIDで404エラーが発生すること', async () => {
      const { app } = getTestContext();

      const response = await request(app)
        .put('/api/v1/engineers/nonexistent-id')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ name: '更新テスト' })
        .expect(404);

      expect(response.body.success).toBe(false);
      expect(response.body.error.code).toBe('ENGINEER_NOT_FOUND');
    });
  });
});
```

### 3.2 認証フロー結合テスト

```typescript
// src/__tests__/integration/auth-flow.test.ts
import request from 'supertest';
import { getTestContext } from './setup';

describe('Authentication Flow Integration', () => {
  describe('完全な認証フロー', () => {
    it('ユーザー登録からログインまでの完全フローが動作すること', async () => {
      const { app } = getTestContext();

      // 1. ユーザー登録
      const registerData = {
        name: 'フローテストユーザー',
        email: 'flowtest@testcompany.com',
        password: 'TestPassword123!',
        companyId: 'test-company-id',
        invitationToken: 'valid-invitation-token'
      };

      const registerResponse = await request(app)
        .post('/api/v1/auth/register')
        .send(registerData)
        .expect(201);

      expect(registerResponse.body.success).toBe(true);
      expect(registerResponse.body.data.user.email).toBe(registerData.email);

      // 2. ログイン
      const loginResponse = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: registerData.email,
          password: registerData.password
        })
        .expect(200);

      expect(loginResponse.body.success).toBe(true);
      const { accessToken } = loginResponse.body.data.tokens;

      // 3. 認証が必要なエンドポイントへのアクセス
      const protectedResponse = await request(app)
        .get('/api/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);

      expect(protectedResponse.body.data.user.email).toBe(registerData.email);

      // 4. ログアウト
      const logoutResponse = await request(app)
        .post('/api/v1/auth/logout')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);

      expect(logoutResponse.body.success).toBe(true);

      // 5. ログアウト後のアクセステスト
      await request(app)
        .get('/api/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(401);
    });

    it('MFA有効ユーザーの認証フローが動作すること', async () => {
      const { app } = getTestContext();

      // MFA有効ユーザーでログイン
      const loginResponse = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'mfa@testcompany.com',
          password: 'testpassword123'
        })
        .expect(202);

      expect(loginResponse.body.success).toBe(false);
      expect(loginResponse.body.error.code).toBe('MFA_REQUIRED');
      const { tempToken } = loginResponse.body.error.details;

      // MFA認証
      const mfaResponse = await request(app)
        .post('/api/v1/auth/mfa/verify')
        .send({
          tempToken,
          mfaCode: '123456' // テスト用の固定コード
        })
        .expect(200);

      expect(mfaResponse.body.success).toBe(true);
      expect(mfaResponse.body.data.tokens.accessToken).toBeDefined();
    });
  });

  describe('トークン更新フロー', () => {
    it('リフレッシュトークンでアクセストークンを更新できること', async () => {
      const { app } = getTestContext();

      // ログイン
      const loginResponse = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'test@testcompany.com',
          password: 'testpassword123'
        });

      const { refreshToken } = loginResponse.body.data.tokens;

      // トークン更新
      const refreshResponse = await request(app)
        .post('/api/v1/auth/refresh')
        .send({ refreshToken })
        .expect(200);

      expect(refreshResponse.body.success).toBe(true);
      expect(refreshResponse.body.data.tokens.accessToken).toBeDefined();
      expect(refreshResponse.body.data.tokens.refreshToken).toBeDefined();
    });

    it('無効なリフレッシュトークンでエラーが発生すること', async () => {
      const { app } = getTestContext();

      const response = await request(app)
        .post('/api/v1/auth/refresh')
        .send({ refreshToken: 'invalid-token' })
        .expect(401);

      expect(response.body.success).toBe(false);
      expect(response.body.error.code).toBe('INVALID_REFRESH_TOKEN');
    });
  });
});
```

## 4. システムテスト（E2Eテスト）設計

### 4.1 Playwrightセットアップ

#### 4.1.1 Playwright設定
```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['junit', { outputFile: 'test-results/junit.xml' }],
    ['allure-playwright']
  ],
  use: {
    baseURL: process.env.E2E_BASE_URL || 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});
```

#### 4.1.2 E2Eテストヘルパー
```typescript
// e2e/helpers/auth.ts
import { Page } from '@playwright/test';

export class AuthHelper {
  constructor(private page: Page) {}

  async login(email: string, password: string) {
    await this.page.goto('/login');
    await this.page.fill('[data-testid="email-input"]', email);
    await this.page.fill('[data-testid="password-input"]', password);
    await this.page.click('[data-testid="login-button"]');
    
    // ログイン成功の確認
    await this.page.waitForURL('/dashboard');
    await this.page.waitForSelector('[data-testid="user-menu"]');
  }

  async loginAsAdmin() {
    await this.login('admin@testcompany.com', 'testpassword123');
  }

  async loginAsSales() {
    await this.login('sales@testcompany.com', 'testpassword123');
  }

  async loginAsEngineer() {
    await this.login('engineer@testcompany.com', 'testpassword123');
  }

  async logout() {
    await this.page.click('[data-testid="user-menu"]');
    await this.page.click('[data-testid="logout-button"]');
    await this.page.waitForURL('/login');
  }
}

// e2e/helpers/engineer.ts
export class EngineerHelper {
  constructor(private page: Page) {}

  async createEngineer(engineerData: {
    name: string;
    email: string;
    engineerType: string;
    nearestStation?: string;
  }) {
    await this.page.goto('/engineers');
    await this.page.click('[data-testid="new-engineer-button"]');
    
    // フォーム入力
    await this.page.fill('[data-testid="engineer-name"]', engineerData.name);
    await this.page.fill('[data-testid="engineer-email"]', engineerData.email);
    await this.page.selectOption('[data-testid="engineer-type"]', engineerData.engineerType);
    
    if (engineerData.nearestStation) {
      await this.page.fill('[data-testid="nearest-station"]', engineerData.nearestStation);
    }

    await this.page.click('[data-testid="submit-button"]');
    
    // 成功メッセージの確認
    await this.page.waitForSelector('[data-testid="success-message"]');
  }

  async searchEngineers(searchTerm: string, filters?: {
    status?: string;
    skills?: string[];
  }) {
    await this.page.goto('/engineers');
    
    // 検索キーワード入力
    await this.page.fill('[data-testid="search-input"]', searchTerm);
    
    // フィルター設定
    if (filters?.status) {
      await this.page.selectOption('[data-testid="status-filter"]', filters.status);
    }
    
    if (filters?.skills) {
      for (const skill of filters.skills) {
        await this.page.fill('[data-testid="skill-filter"]', skill);
        await this.page.keyboard.press('Enter');
      }
    }
    
    // 検索実行
    await this.page.click('[data-testid="search-button"]');
    await this.page.waitForSelector('[data-testid="engineer-list"]');
  }

  async updateSkillSheet(engineerId: string, skillData: {
    summary: string;
    programmingLanguages: Array<{name: string, level: number}>;
  }) {
    await this.page.goto(`/engineers/${engineerId}/skill-sheet`);
    
    // サマリー更新
    await this.page.fill('[data-testid="skill-summary"]', skillData.summary);
    
    // プログラミング言語追加
    for (const lang of skillData.programmingLanguages) {
      await this.page.click('[data-testid="add-programming-language"]');
      await this.page.fill('[data-testid="language-name"]:last-of-type', lang.name);
      await this.page.click(`[data-testid="language-level-${lang.level}"]:last-of-type`);
    }
    
    // 保存
    await this.page.click('[data-testid="save-skillsheet"]');
    await this.page.waitForSelector('[data-testid="save-success"]');
  }
}
```

### 4.2 主要E2Eテストシナリオ

#### 4.2.1 ユーザー管理シナリオ
```typescript
// e2e/user-management.spec.ts
import { test, expect } from '@playwright/test';
import { AuthHelper } from './helpers/auth';

test.describe('ユーザー管理シナリオ', () => {
  let authHelper: AuthHelper;

  test.beforeEach(async ({ page }) => {
    authHelper = new AuthHelper(page);
  });

  test('管理者がユーザーを作成・編集・削除できること', async ({ page }) => {
    // 管理者ログイン
    await authHelper.loginAsAdmin();

    // ユーザー管理画面へ
    await page.click('[data-testid="nav-users"]');
    await page.waitForSelector('[data-testid="user-list"]');

    // 新規ユーザー作成
    await page.click('[data-testid="new-user-button"]');
    
    const newUserData = {
      name: 'テストユーザー',
      email: 'newuser@testcompany.com',
      roles: ['engineer']
    };

    await page.fill('[data-testid="user-name"]', newUserData.name);
    await page.fill('[data-testid="user-email"]', newUserData.email);
    await page.check('[data-testid="role-engineer"]');
    await page.click('[data-testid="create-user-button"]');

    // 作成成功の確認
    await page.waitForSelector('[data-testid="user-created-message"]');
    await expect(page.locator('[data-testid="user-list"]')).toContainText(newUserData.name);

    // ユーザー編集
    await page.click(`[data-testid="edit-user-${newUserData.email}"]`);
    await page.fill('[data-testid="user-name"]', 'テストユーザー（編集後）');
    await page.check('[data-testid="role-sales"]');
    await page.click('[data-testid="update-user-button"]');

    // 編集成功の確認
    await page.waitForSelector('[data-testid="user-updated-message"]');
    await expect(page.locator('[data-testid="user-list"]')).toContainText('テストユーザー（編集後）');

    // ユーザー削除
    await page.click(`[data-testid="delete-user-${newUserData.email}"]`);
    await page.click('[data-testid="confirm-delete"]');

    // 削除成功の確認
    await page.waitForSelector('[data-testid="user-deleted-message"]');
    await expect(page.locator('[data-testid="user-list"]')).not.toContainText('テストユーザー（編集後）');
  });

  test('権限のないユーザーはユーザー管理にアクセスできないこと', async ({ page }) => {
    // エンジニアでログイン
    await authHelper.loginAsEngineer();

    // ユーザー管理画面への直接アクセスを試行
    await page.goto('/users');
    
    // 403エラーまたはダッシュボードにリダイレクトされることを確認
    await page.waitForURL(/\/(dashboard|403)/);
    
    // ナビゲーションにユーザー管理が表示されないことを確認
    await expect(page.locator('[data-testid="nav-users"]')).not.toBeVisible();
  });
});
```

#### 4.2.2 エンジニア管理シナリオ
```typescript
// e2e/engineer-management.spec.ts
import { test, expect } from '@playwright/test';
import { AuthHelper, EngineerHelper } from './helpers';

test.describe('エンジニア管理シナリオ', () => {
  let authHelper: AuthHelper;
  let engineerHelper: EngineerHelper;

  test.beforeEach(async ({ page }) => {
    authHelper = new AuthHelper(page);
    engineerHelper = new EngineerHelper(page);
  });

  test('営業担当者がエンジニア登録からスキルシート完成まで行えること', async ({ page }) => {
    // 営業担当者ログイン
    await authHelper.loginAsSales();

    // エンジニア作成
    const engineerData = {
      name: 'E2Eテストエンジニア',
      email: 'e2etest@testcompany.com',
      engineerType: 'employee',
      nearestStation: '新宿駅'
    };

    await engineerHelper.createEngineer(engineerData);

    // エンジニア一覧で作成されたエンジニアを確認
    await page.goto('/engineers');
    await expect(page.locator('[data-testid="engineer-list"]')).toContainText(engineerData.name);

    // エンジニア詳細ページへ
    await page.click(`text=${engineerData.name}`);
    await page.waitForSelector('[data-testid="engineer-detail"]');

    // スキルシートタブに切り替え
    await page.click('[data-testid="tab-skillsheet"]');

    // スキルシート編集
    await page.click('[data-testid="edit-skillsheet"]');

    const skillData = {
      summary: 'フルスタックエンジニアとして5年間の経験があります。',
      programmingLanguages: [
        { name: 'JavaScript', level: 4 },
        { name: 'TypeScript', level: 3 }
      ]
    };

    await engineerHelper.updateSkillSheet('test-engineer-id', skillData);

    // スキルシート完成の確認
    await expect(page.locator('[data-testid="skillsheet-status"]')).toContainText('完成');
    await expect(page.locator('[data-testid="skillsheet-summary"]')).toContainText(skillData.summary);
  });

  test('エンジニア検索とフィルタリングが正しく動作すること', async ({ page }) => {
    await authHelper.loginAsSales();

    // 検索とフィルタリング実行
    await engineerHelper.searchEngineers('JavaScript', {
      status: 'waiting',
      skills: ['React', 'Node.js']
    });

    // 検索結果の確認
    const results = page.locator('[data-testid="engineer-item"]');
    const count = await results.count();
    expect(count).toBeGreaterThan(0);

    // 各結果がフィルター条件に合致することを確認
    for (let i = 0; i < count; i++) {
      const item = results.nth(i);
      await expect(item.locator('[data-testid="engineer-status"]')).toContainText('待機中');
      await expect(item.locator('[data-testid="engineer-skills"]')).toContainText('JavaScript');
    }
  });

  test('エンジニアが自分のスキルシートを更新できること', async ({ page }) => {
    await authHelper.loginAsEngineer();

    // 自分のスキルシートページへ
    await page.click('[data-testid="nav-my-skillsheet"]');
    await page.waitForSelector('[data-testid="skillsheet-form"]');

    // スキルシート更新
    await page.fill('[data-testid="skill-summary"]', '更新されたスキル概要です。');
    
    // プログラミング言語追加
    await page.click('[data-testid="add-skill-button"]');
    await page.fill('[data-testid="skill-name"]:last-of-type', 'Python');
    await page.click('[data-testid="skill-level-3"]:last-of-type');
    
    // 保存
    await page.click('[data-testid="save-skillsheet"]');
    await page.waitForSelector('[data-testid="save-success"]');

    // 保存確認
    await page.reload();
    await expect(page.locator('[data-testid="skill-summary"]')).toHaveValue('更新されたスキル概要です。');
    await expect(page.locator('[data-testid="skills-list"]')).toContainText('Python');
  });
});
```

#### 4.2.3 アプローチ管理シナリオ
```typescript
// e2e/approach-management.spec.ts
import { test, expect } from '@playwright/test';
import { AuthHelper } from './helpers/auth';

test.describe('アプローチ管理シナリオ', () => {
  let authHelper: AuthHelper;

  test.beforeEach(async ({ page }) => {
    authHelper = new AuthHelper(page);
  });

  test('営業担当者がアプローチを作成・送信できること', async ({ page }) => {
    await authHelper.loginAsSales();

    // アプローチ作成画面へ
    await page.click('[data-testid="nav-approaches"]');
    await page.click('[data-testid="new-approach-button"]');

    // アプローチ作成フォーム（ステップ1：対象選択）
    await page.check('[data-testid="target-company"]');
    await page.selectOption('[data-testid="company-select"]', 'client-company-1');
    
    // エンジニア選択
    await page.check('[data-testid="engineer-eng-1"]');
    await page.check('[data-testid="engineer-eng-2"]');
    await page.click('[data-testid="next-step"]');

    // ステップ2：メッセージ作成
    await page.fill('[data-testid="project-name"]', 'React開発プロジェクト');
    await page.fill('[data-testid="project-description"]', 'React/TypeScriptを使用したWebアプリケーション開発');
    await page.fill('[data-testid="message-content"]', 'いつもお世話になっております。新規プロジェクトでエンジニアを募集しております。');
    await page.check('[data-testid="contact-email"]');
    await page.click('[data-testid="next-step"]');

    // ステップ3：確認・送信
    await expect(page.locator('[data-testid="confirm-company"]')).toContainText('クライアント企業A');
    await expect(page.locator('[data-testid="confirm-engineers"]')).toContainText('2名選択済み');
    await expect(page.locator('[data-testid="confirm-project"]')).toContainText('React開発プロジェクト');

    await page.click('[data-testid="send-approach"]');

    // 送信成功確認
    await page.waitForSelector('[data-testid="approach-sent-success"]');
    await expect(page.locator('[data-testid="success-message"]')).toContainText('アプローチを送信しました');

    // アプローチ履歴に記録されることを確認
    await page.click('[data-testid="nav-approach-history"]');
    await expect(page.locator('[data-testid="approach-list"] >> nth=0')).toContainText('React開発プロジェクト');
    await expect(page.locator('[data-testid="approach-status"] >> nth=0')).toContainText('送信済み');
  });

  test('定期アプローチの設定ができること', async ({ page }) => {
    await authHelper.loginAsSales();

    // 定期アプローチ設定画面へ
    await page.click('[data-testid="nav-approaches"]');
    await page.click('[data-testid="periodic-approaches-tab"]');
    await page.click('[data-testid="new-periodic-approach"]');

    // 定期アプローチ設定
    await page.fill('[data-testid="periodic-name"]', '月次エンジニア紹介');
    await page.selectOption('[data-testid="target-company"]', 'client-company-1');
    await page.selectOption('[data-testid="frequency"]', 'monthly');
    await page.selectOption('[data-testid="day-of-month"]', '1');
    
    // 対象エンジニア条件設定
    await page.check('[data-testid="status-waiting"]');
    await page.fill('[data-testid="skill-filter"]', 'JavaScript');
    await page.keyboard.press('Enter');

    // メールテンプレート選択
    await page.selectOption('[data-testid="email-template"]', 'template-monthly');

    await page.click('[data-testid="create-periodic-approach"]');

    // 作成成功確認
    await page.waitForSelector('[data-testid="periodic-created-success"]');
    await expect(page.locator('[data-testid="periodic-list"]')).toContainText('月次エンジニア紹介');
    await expect(page.locator('[data-testid="periodic-status"]')).toContainText('有効');
  });
});
```

## 5. 受入テスト設計

### 5.1 受入テスト基準
```typescript
// tests/acceptance/criteria.ts

export interface AcceptanceCriteria {
  story: string;
  criteria: Array<{
    given: string;
    when: string;
    then: string;
    testMethod: 'automated' | 'manual';
  }>;
}

export const acceptanceCriteria: AcceptanceCriteria[] = [
  {
    story: 'エンジニア登録機能',
    criteria: [
      {
        given: '管理者または営業権限を持つユーザーがログインしている',
        when: '必要な情報を入力してエンジニア登録を実行する',
        then: 'エンジニアが正常に登録され、一覧に表示される',
        testMethod: 'automated'
      },
      {
        given: '同じメールアドレスのエンジニアが既に存在する',
        when: '重複するメールアドレスでエンジニア登録を試行する',
        then: 'エラーメッセージが表示され、登録が拒否される',
        testMethod: 'automated'
      },
      {
        given: '必須項目が未入力の状態で',
        when: 'エンジニア登録を試行する',
        then: 'バリデーションエラーが表示され、登録が完了しない',
        testMethod: 'automated'
      }
    ]
  },
  {
    story: 'スキルシート管理機能',
    criteria: [
      {
        given: 'エンジニア本人がログインしている',
        when: '自分のスキルシート情報を更新する',
        then: '変更が保存され、他のユーザーに最新情報が表示される',
        testMethod: 'automated'
      },
      {
        given: 'スキルシートが完成状態になっている',
        when: '取引先企業がそのエンジニアを閲覧する',
        then: '完成したスキルシート情報が表示される',
        testMethod: 'manual'
      }
    ]
  },
  {
    story: 'アプローチ機能',
    criteria: [
      {
        given: '営業担当者がログインしており、エンジニアと取引先企業が存在する',
        when: 'エンジニアを選択してアプローチを送信する',
        then: '取引先企業にメールが送信され、アプローチ履歴に記録される',
        testMethod: 'automated'
      },
      {
        given: '定期アプローチが設定されている',
        when: '設定された日時になる',
        then: '自動的にアプローチメールが送信される',
        testMethod: 'manual'
      }
    ]
  }
];
```

### 5.2 受入テスト実行計画
```markdown
# 受入テスト実行計画書

## 実行概要
- **実行期間**: 開発完了後 1週間
- **実行環境**: ステージング環境
- **参加者**: 
  - 開発チーム（テスト実行・サポート）
  - プロダクトオーナー（受入判定）
  - エンドユーザー代表（実際の操作確認）

## 実行手順

### Phase 1: 自動テスト実行（1日目）
1. E2Eテストスイート実行
2. API結合テスト実行
3. パフォーマンステスト実行
4. セキュリティテスト実行
5. 自動テスト結果レビュー

### Phase 2: 手動テスト実行（2-4日目）
1. ユーザーシナリオベーステスト
2. ブラウザ互換性テスト
3. モバイル対応テスト
4. アクセシビリティテスト
5. ユーザビリティテスト

### Phase 3: 受入判定（5日目）
1. テスト結果総合評価
2. 未解決問題の優先度判定
3. 受入基準適合確認
4. 本番リリース可否判定
```

## 6. 自動テスト戦略

### 6.1 テスト自動化パイプライン
```yaml
# .github/workflows/test-pipeline.yml
name: Test Pipeline

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        cd backend && npm ci
        cd ../frontend && npm ci
    
    - name: Run unit tests
      run: |
        cd backend && npm run test:unit -- --coverage
        cd ../frontend && npm run test:unit -- --coverage
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        directory: ./coverage

  integration-tests:
    needs: unit-tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v