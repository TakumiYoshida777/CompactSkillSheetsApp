# システム設計開発方針

## 基本ルール

### 開発作業の基本原則
1. **プロジェクトナレッジの必須確認**
   - すべての思考・作業の前に、必ずCompactSkillSheetsApp/_Documentsに格納されているすべてのファイルを読み、理解すること
   - 既存の設計書・仕様書との整合性を常に確認すること
   - 不明な点は推測せず、既存ドキュメントを参照すること

2. **日本語対応の徹底**
   - すべての対話は日本語で行うこと
   - すべてのドキュメント、コメント、エラーメッセージは日本語で記述すること
   - 日本人向けのシステムであることを理解し、日本のビジネス慣習を考慮すること
   - 多言語対応は不要（日本語のみ）
   - 日付形式：YYYY年MM月DD日、時刻形式：HH:mm:ss（24時間表記）
   - 通貨形式：￥記号使用、3桁カンマ区切り

3. **作業後の必須セルフレビュー**
   - 作業完了後は必ず以下の観点でセルフレビューを実施すること：
     - **整合性確認**：既存の設計・仕様との不整合がないか
     - **完全性確認**：要求された内容に過不足がないか
     - **要件充足確認**：すべての要件を満たしているか
     - **品質確認**：致命的なミスやバグが含まれていないか
     - **可読性確認**：AIや他の開発者が読んで誤解しない表現になっているか

## フロントエンド開発方針

### React.js開発の基本原則

1. **コンポーネント設計**
   ```typescript
   // 単一責任の原則に従う
   // ❌ 悪い例：複数の責任を持つコンポーネント
   const UserDashboard = () => {
     // ユーザー情報取得、グラフ描画、通知処理すべてを含む
   };

   // ⭕ 良い例：責任を分離
   const UserDashboard = () => {
     return (
       <>
         <UserInfo />
         <UserStatistics />
         <NotificationPanel />
       </>
     );
   };
   ```

2. **状態管理の原則**
   - ローカル状態：コンポーネント内で完結する状態はuseStateを使用
   - グローバル状態：Zustandを使用（Redux不要、シンプルさ重視）
   - サーバー状態：TanStack Query（React Query）で管理
   ```typescript
   // Zustand Store例
   import { create } from 'zustand';
   
   interface UserStore {
     user: User | null;
     setUser: (user: User) => void;
     clearUser: () => void;
   }
   
   export const useUserStore = create<UserStore>((set) => ({
     user: null,
     setUser: (user) => set({ user }),
     clearUser: () => set({ user: null }),
   }));
   ```

3. **Hooksの活用**
   - カスタムHooksで共通ロジックを抽出
   - useCallback/useMemoで適切にパフォーマンス最適化
   ```typescript
   // カスタムHook例
   export const useAuth = () => {
     const { user } = useUserStore();
     const queryClient = useQueryClient();
     
     const login = useCallback(async (credentials: LoginCredentials) => {
       const response = await authApi.login(credentials);
       queryClient.invalidateQueries(['user']);
       return response;
     }, [queryClient]);
     
     return { user, login };
   };
   ```

4. **TypeScriptの活用**
   - すべてのコンポーネントで型定義を必須とする
   - anyの使用禁止（やむを得ない場合はコメント必須）
   - 共通の型定義は`types/`ディレクトリに集約
   ```typescript
   // 型定義例
   interface ButtonProps {
     variant: 'primary' | 'secondary' | 'danger';
     size?: 'small' | 'medium' | 'large';
     onClick: () => void;
     disabled?: boolean;
     children: React.ReactNode;
   }
   ```

5. **スタイリング方針**
   - Tailwind CSSを基本とする（設定済みクラスのみ使用）
   - 複雑なスタイルはStyled Componentsで補完
   - レスポンシブデザイン必須（モバイルファースト）
   ```tsx
   // Tailwind CSS使用例
   const Button: React.FC<ButtonProps> = ({ variant, size = 'medium', children }) => {
     const variants = {
       primary: 'bg-blue-600 hover:bg-blue-700 text-white',
       secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-800',
       danger: 'bg-red-600 hover:bg-red-700 text-white'
     };
     
     const sizes = {
       small: 'px-3 py-1 text-sm',
       medium: 'px-4 py-2',
       large: 'px-6 py-3 text-lg'
     };
     
     return (
       <button className={`rounded-lg transition-colors ${variants[variant]} ${sizes[size]}`}>
         {children}
       </button>
     );
   };
   ```

6. **ディレクトリ構造**
   ```
   src/
   ├── components/        # 共通コンポーネント
   │   ├── common/       # 汎用UI部品
   │   ├── features/     # 機能別コンポーネント
   │   └── layouts/      # レイアウト関連
   ├── hooks/            # カスタムHooks
   ├── pages/            # ページコンポーネント（ルーティング単位）
   ├── services/         # API通信ロジック
   ├── stores/           # Zustand stores
   ├── types/            # TypeScript型定義
   ├── utils/            # ユーティリティ関数
   └── constants/        # 定数定義
   ```

## バックエンド開発方針

### Node.js/Express開発の基本原則

1. **アーキテクチャ設計**
   - Clean Architecture/Onion Architectureの採用
   - 依存関係の逆転原則（DIP）を遵守
   ```
   src/
   ├── domain/           # ビジネスロジック（フレームワーク非依存）
   │   ├── entities/    # ドメインモデル
   │   └── services/    # ドメインサービス
   ├── application/      # ユースケース層
   │   ├── usecases/    # ビジネスユースケース
   │   └── dto/         # データ転送オブジェクト
   ├── infrastructure/   # 技術詳細
   │   ├── database/    # DB接続・リポジトリ実装
   │   ├── external/    # 外部API連携
   │   └── security/    # 認証・暗号化
   └── presentation/     # プレゼンテーション層
       ├── routes/      # ルーティング定義
       ├── controllers/ # コントローラー
       └── middleware/  # Express middleware
   ```

2. **Express.jsベストプラクティス**
   ```typescript
   // エラーハンドリングミドルウェア
   export const errorHandler: ErrorRequestHandler = (
     err: Error,
     req: Request,
     res: Response,
     next: NextFunction
   ) => {
     logger.error({
       error: err.message,
       stack: err.stack,
       url: req.url,
       method: req.method,
       ip: req.ip
     });
     
     if (err instanceof ValidationError) {
       return res.status(400).json({
         error: 'バリデーションエラー',
         details: err.details
       });
     }
     
     if (err instanceof UnauthorizedError) {
       return res.status(401).json({
         error: '認証が必要です'
       });
     }
     
     // デフォルトエラーレスポンス
     res.status(500).json({
       error: 'サーバーエラーが発生しました'
     });
   };
   ```

3. **非同期処理の統一**
   ```typescript
   // 非同期ハンドラーラッパー
   export const asyncHandler = (fn: Function) => {
     return (req: Request, res: Response, next: NextFunction) => {
       Promise.resolve(fn(req, res, next)).catch(next);
     };
   };
   
   // 使用例
   router.get('/users/:id', asyncHandler(async (req, res) => {
     const user = await userService.findById(req.params.id);
     res.json(user);
   }));
   ```

4. **バリデーション戦略**
   - Yupを使用した統一的なバリデーション
   - DTOレベルでの入力検証
   ```typescript
   // バリデーションスキーマ例
   export const createUserSchema = yup.object({
     email: yup
       .string()
       .email('有効なメールアドレスを入力してください')
       .required('メールアドレスは必須です'),
     password: yup
       .string()
       .min(8, 'パスワードは8文字以上必要です')
       .matches(
         /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
         'パスワードは大文字、小文字、数字を含む必要があります'
       )
       .required('パスワードは必須です'),
     name: yup
       .string()
       .max(100, '名前は100文字以内で入力してください')
       .required('名前は必須です')
   });
   ```

5. **データベースアクセス**
   - Prismaを使用したType-safe なDB操作
   - トランザクション管理の徹底
   ```typescript
   // リポジトリパターン例
   export class UserRepository implements IUserRepository {
     constructor(private prisma: PrismaClient) {}
     
     async create(data: CreateUserDto): Promise<User> {
       return await this.prisma.$transaction(async (tx) => {
         // ユーザー作成
         const user = await tx.user.create({
           data: {
             ...data,
             password: await bcrypt.hash(data.password, 10)
           }
         });
         
         // 関連データの作成
         await tx.userProfile.create({
           data: {
             userId: user.id,
             // その他のプロフィール情報
           }
         });
         
         return user;
       });
     }
   }
   ```

6. **セキュリティ実装**
   ```typescript
   // JWT認証ミドルウェア
   export const authenticate = async (
     req: Request,
     res: Response,
     next: NextFunction
   ) => {
     try {
       const token = req.headers.authorization?.replace('Bearer ', '');
       
       if (!token) {
         throw new UnauthorizedError('認証トークンが必要です');
       }
       
       const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;
       const user = await userRepository.findById(decoded.userId);
       
       if (!user) {
         throw new UnauthorizedError('ユーザーが見つかりません');
       }
       
       req.user = user;
       next();
     } catch (error) {
       next(new UnauthorizedError('認証に失敗しました'));
     }
   };
   
   // 権限チェックミドルウェア
   export const authorize = (...roles: string[]) => {
     return (req: Request, res: Response, next: NextFunction) => {
       if (!req.user || !roles.includes(req.user.role)) {
         return next(new ForbiddenError('この操作を実行する権限がありません'));
       }
       next();
     };
   };
   ```

7. **ログ出力標準**
   ```typescript
   // Winston設定例
   import winston from 'winston';
   
   export const logger = winston.createLogger({
     level: process.env.LOG_LEVEL || 'info',
     format: winston.format.combine(
       winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
       winston.format.errors({ stack: true }),
       winston.format.json()
     ),
     transports: [
       new winston.transports.File({ filename: 'error.log', level: 'error' }),
       new winston.transports.File({ filename: 'combined.log' }),
       new winston.transports.Console({
         format: winston.format.combine(
           winston.format.colorize(),
           winston.format.simple()
         )
       })
     ]
   });
   
   // 使用例
   logger.info('ユーザー登録処理開始', { userId: user.id });
   logger.error('データベースエラー', { error: err.message, query });
   ```

## テスト戦略

### フロントエンドテスト
```typescript
// React Testing Library使用例
describe('LoginForm', () => {
  it('正しい認証情報でログインできること', async () => {
    const mockLogin = jest.fn();
    render(<LoginForm onLogin={mockLogin} />);
    
    const emailInput = screen.getByLabelText('メールアドレス');
    const passwordInput = screen.getByLabelText('パスワード');
    const submitButton = screen.getByRole('button', { name: 'ログイン' });
    
    await userEvent.type(emailInput, 'test@example.com');
    await userEvent.type(passwordInput, 'password123');
    await userEvent.click(submitButton);
    
    expect(mockLogin).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123'
    });
  });
});
```

### バックエンドテスト
```typescript
// Jest + Supertestの例
describe('POST /api/users', () => {
  it('新規ユーザーを作成できること', async () => {
    const userData = {
      email: 'new@example.com',
      password: 'Test1234!',
      name: '新規ユーザー'
    };
    
    const response = await request(app)
      .post('/api/users')
      .send(userData)
      .expect(201);
    
    expect(response.body).toMatchObject({
      id: expect.any(String),
      email: userData.email,
      name: userData.name
    });
    
    // パスワードがレスポンスに含まれていないことを確認
    expect(response.body.password).toBeUndefined();
  });
});
```