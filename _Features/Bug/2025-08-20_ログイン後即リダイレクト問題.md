# ログイン後即座にログイン画面にリダイレクトされる問題

## 発生日
2025年8月20日

## 環境
- 開発環境: Dev2 (http://localhost:3001 / API: http://localhost:8001)
- フロントエンド: React 18 + TypeScript + Vite + Zustand (persist)
- バックエンド: Node.js + Express + Prisma + JWT
- ブラウザ: 各種ブラウザで再現

## 問題の概要
ログインに成功し、ダッシュボード画面に遷移した直後に、すぐにログイン画面に戻されてしまう。

## 症状の詳細
1. ログインフォームでメールアドレスとパスワードを入力
2. 「ログインに成功しました」というメッセージが表示される
3. `/dashboard`に遷移する
4. 一瞬ダッシュボードが表示される
5. すぐに`/login`にリダイレクトされる

## コンソールログの状況
```
[Axios Interceptor] Adding token to request: No token
[AuthService] Token set in store for interceptor: Token exists
[checkAuth] Starting - Token: true User: {id: 'user-admin-1', email: 'admin@demo-ses.co.jp', ...} Status: authenticated
[checkAuth] UserType from token: null
[checkAuth] Using endpoint: /api/auth/me UserType: undefined
[AuthService] Fetching user info from: /api/auth/me
[AuthService] Current Authorization header: undefined
[Axios Interceptor] Adding token to request: Token exists
[Axios Interceptor] Authorization header set
[AuthGuard] Checking authentication, showing spinner
GET http://localhost:8001/api/auth/me 404 (Not Found)
[checkAuth] Request failed: Request failed with status code 404
[checkAuth] Auth check failed
[AuthGuard] Not authenticated, redirecting to: login
```

## 特定された問題点

### 1. 複数の問題が重複して発生
- **rehydrationレース**: LocalStorage復元前にAuthGuardが動作
- **isAuthenticatedの永続化問題**: トークンと認証状態の不整合
- **React 18 StrictMode**: 開発環境でのuseEffect二重実行
- **checkAuthの重複実行**: App.tsxとAuthGuardで二重に実行

### 2. APIエンドポイントの問題
- `/api/auth/me`が404を返す（実際は存在するが何らかの理由でアクセスできない）
- トークンがAxiosインターセプターで正しく設定されているが、実際のリクエストには含まれていない可能性

### 3. 状態管理の不整合
- ログイン成功時: `status: 'authenticated'`
- しかしcheckAuth実行時にはstatusがリセットされている
- LocalStorageとZustandストアの同期問題

## 試した修正内容（すべて効果なし）

### 1. CORS設定の修正
```typescript
// docker-compose.yml
CORS_ORIGIN=http://localhost:3000,http://localhost:3001

// backend/src/index.ts
const corsOrigins = process.env.CORS_ORIGIN 
  ? process.env.CORS_ORIGIN.split(',') 
  : ['http://localhost:3000', 'http://localhost:3001'];
```

### 2. isAuthenticatedを導出値に変更
```typescript
// 永続化から除外し、token && userから都度計算
const useIsAuthenticated = () => 
  useAuthStore((state) => Boolean(state.token && state.user));
```

### 3. rehydration完了待機の実装
```typescript
export const useStoreHydrated = () => {
  const [hydrated, setHydrated] = React.useState(
    useAuthStore.persist.hasHydrated()
  );
  
  React.useEffect(() => {
    const unsubscribe = useAuthStore.persist.onFinishHydration(() => {
      setHydrated(true);
    });
    return unsubscribe;
  }, []);
  
  return hydrated;
};
```

### 4. AuthGuardの改善
```typescript
// ハイドレーション完了前は何もしない
if (!hydrated) {
  return <Spin />;
}

// 既に認証済みの場合はcheckAuthをスキップ
if (status === 'authenticated') {
  return;
}
```

### 5. Axiosインターセプターの改善
```typescript
// リフレッシュトークンのキュー処理実装
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (token: string) => void;
  reject: (error: any) => void;
}> = [];

// window.location.hrefによる即座のリダイレクトを廃止
// AuthGuardにリダイレクト処理を一元化
```

### 6. APIエンドポイントパスの修正
```typescript
// 二重の/api/を削除
const endpoint = userType === 'client' ? 'client/auth/me' : 'auth/me';
// axiosのbaseURLに既に/apiが含まれている
```

### 7. checkAuthの重複削除
```typescript
// App.tsxから削除（AuthGuardに一元化）
// 削除前：
useEffect(() => {
  if (token) {
    checkAuth();
  }
}, [token, checkAuth]);
```

### 8. statusの永続化
```typescript
// LocalStorageにstatusも保存
partialize: (state) => ({
  user: state.user,
  token: state.token,
  refreshToken: state.refreshToken,
  status: state.status, // 追加
})

// rehydration時の処理
onRehydrateStorage: () => (state) => {
  if (state?.token && state?.user) {
    if (state.status !== 'authenticated') {
      state.status = 'authenticated';
    }
  }
}
```

### 9. ユーザータイプ判定の改善
```typescript
// JWTトークンにuserTypeが含まれていない場合の対応
if (!userType && user?.roles) {
  if (user.roles.includes('client_admin') || user.roles.includes('client_user')) {
    userType = 'client';
  } else {
    userType = 'ses';
  }
}
```

### 10. デバッグログの追加
- バックエンドの認証ミドルウェアにログ追加
- フロントエンドの各所にコンソールログ追加
- Axiosインターセプターにトークン送信ログ追加

## 現在の状況
- 上記すべての修正を適用しても問題は解決していない
- ログイン成功直後は`status: 'authenticated'`だが、なぜかcheckAuthが呼ばれて失敗する
- `/api/auth/me`エンドポイントは存在するが404を返す
- トークンはZustandストアに保存されているが、APIリクエスト時に正しく送信されていない可能性

## 疑われる根本原因
1. **Zustand persistとrehydrationのタイミング問題**
   - LocalStorage復元とコンポーネントレンダリングの競合
   - 状態の初期化タイミングの不整合

2. **Axiosインスタンスの問題**
   - トークンがストアに保存されているが、Axiosインターセプターで取得できない
   - 複数のAxiosインスタンスが存在する可能性

3. **バックエンドのルーティング問題**
   - `/api/auth/me`エンドポイントの実装に問題がある可能性
   - 認証ミドルウェアの処理順序の問題

## 推奨される次のステップ
1. **LocalStorageの内容を直接確認**
   - ブラウザのDevToolsで`auth-storage`キーの内容を確認
   - トークンが実際に保存されているか確認

2. **ネットワークタブで詳細確認**
   - `/api/auth/me`リクエストのヘッダーを確認
   - Authorizationヘッダーが実際に送信されているか確認

3. **バックエンドのログを詳細に確認**
   - Dockerコンテナのログを確認
   - 認証ミドルウェアでトークンが受信されているか確認

4. **単純化したテスト環境の構築**
   - StrictModeを無効化してテスト
   - persistを無効化してテスト
   - シンプルな認証フローのみでテスト

## 関連ファイル
- `/frontend/src/stores/authStore.ts`
- `/frontend/src/components/guards/AuthGuard.tsx`
- `/frontend/src/lib/axios.ts`
- `/frontend/src/services/authService.ts`
- `/frontend/src/services/authCheckService.ts`
- `/frontend/src/App.tsx`
- `/backend/src/middleware/auth.middleware.ts`
- `/backend/src/routes/authRoutes.ts`
- `/backend/src/controllers/authController.ts`

## 参考ナレッジ
- `_Knowledge/JWT認証401エラー_Axiosインスタンス不一致問題.md`
- `_Features/Bug/Prompt/2025-08-20_login_redirect_issue.md`

## 結論
複数の修正を試みたが、問題は解決していない。根本原因は複数の要因が重なっている可能性が高く、一つずつ切り分けて検証する必要がある。特にZustandのpersistとrehydrationのタイミング、およびAxiosインスタンスのトークン管理に問題がある可能性が高い。